秒杀抢购活动是现在很多商城常见的营销手段，小米抢购、淘宝的整点免单、
聚划算等都是成功的例子。

从简单处着手，'秒杀'是很好理解的：'设置'要秒杀的商品的'数量'，'抢完为止'。
但是，'实际'应用'中'一瞬间的'高并发压力'、以及'并发带来的负库存'是'要着重考虑'。

要'避免负库存的出现'，可以'在数据库加锁'，'不管外部多少请求'，都'可以在数据库操作前'给'阻断'。
当然，这种'思路'可以'用在流量不大'的'普通商品上'，用在'高并发'的'秒杀商品'上显然是'不合适'的，
直接'高频率'的'读写操作数据库'，对'数据库的压力太大'，严重'拖性能'，
'量大'的话'挂掉也'是'很有可能'的。

'这时'候就'需要用'到'缓存队列'了，现在前面'应用层'处理'并发'，这个'资源的消耗'是'比较小'的，
内存中的'处理效率'也会'很快'。'队列''处理完'之后'再向数据库'层进行'请求操作'。

当然，有时候'还有可能'会'用到文件排他锁'，在'处理一个订单的时候'，使用flock'锁定文件'，
如果'锁定失败'说明'有其他进程'正在'锁文件处理'订单，'返回失败'。但是只使用这个的话，
个人感觉不太好，我宁愿'让用户'在'队列中'多'等待'几秒，也不想直接返回失败。
可以在缓存队列到数据库的时候使用下这个，多加一层安全系数。

模拟场景：
商城做一个秒杀活动，秒杀的商品数量为10，秒到即得。

方案：
1、'应用层'做'首次过滤'
因为考虑到处理的失败，我们'要给缓存'开的'总数比10稍大'是最好的，那我们就给'队列开的总数是50'。
秒杀开始后，我们的'队列'只'接收前面50个请求'，当'数量满50后'，在请求就'返回已秒杀完'。
如果'一瞬间的并发大于50'，我们就'随机取50个放入队列'。
'缓存的处理'是在内存上处理的，效率非常高，但是在这个层面处理过'之后'要'二次请求'，
可能会有稍许延迟。
2、数据层做二次过滤
从'50个'中随机或者排序的方式，二次“并发”'按队列执行下单'，这时候可以考虑使用文件锁。
'入库时'也可考虑'使用乐观锁'、自定义锁、限制条件'等'。
经过'首次处理后'的'数据量'已经非常'小'了，直接'操作数据库'的话'压力会小很多'，
'二次过滤'也能尽可能的'保证数据不超出'。
其他：
如果是分布式集群服务器，就需要有一个或多个多层专门的队列服务器，或者配置缓存队列共享。

此方案成立的前提是并发量很大，能接近或者超过放出的数量。如果商品库存很足，
而且并发量不大，反倒影响了用户体验。

本文来自Ruesin博客
这种二次过滤的架构，下来之后，能最大限度的保证程序的严谨性。

Ruesin.com
小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。
而淘宝则重在付款的时候的过滤，做了多层过滤，比如要'卖10件商品'，他会让'大于10的用户抢到'，
在'付款的时候'再进行'并发过滤'，一层层的减少一瞬间的并发量。