要了解Java垃圾收集机制，先理解'JVM内存模式'是非常重要的。今天我们将会了解JVM内存的各个部分、
如何监控以及垃圾收集调优。
Java（JVM）内存模型

https://note.youdao.com/web/#/file/390BCD89A3F34D15ABF9459E82678802/note/5312D5D906F34A5197BC3446A23AAEC2/

正如你从上面的图片看到的，JVM内存被分成多个独立的部分。广泛地说，JVM堆内存被分为
两部分——'年轻代'（Young Generation）和'老年代'（Old Generation）。
年轻代
'年轻代'是所有'新对象产生的地方'。当'年轻代'内存空间'被用完'时，就会'触发垃圾回收'。这个垃圾
回收叫做'Minor GC'。年轻代被分为3个部分——Enden区和两个Survivor区。
年轻代空间的要点：
大多数'新建'的'对象'都'位于Eden区'。
当'Eden区'被对象'填满'时，就'会执行Minor GC'。并把所有'存活'下来'的对象'转'移到'其中一个'survivor区'。
'Minor GC'同样会'检查存活'下来的'对象'，并把它们'转移到''另一个survivor区'。这样在一段时间内，
总会有一个空的survivor区。
经过'多次GC'周期后，'仍然存活'下来'的对象'会'被转移到年老代'内存空间。通常这是在年轻代有资格
提升到年老代前'通过设定年龄阈值'来'完成'的。
年老代
'年老代'内存里'包含'了'长期存活'的'对象'和经过多次Minor GC后依然存活下来的对象。通常会在'老年'
'代'内存'被占满'时'进行垃圾回收'。老年代的垃圾收集叫做Major GC。Major GC会花费更多的时间。
Stop the World事件
所有的'垃圾收集(时)'都是“Stop the World”事件，因为'所有的应用线程'都'会停下来''直到操作完成'
（所以叫“Stop the World”）。
因为'年轻代'里的对象都'是一些临时（short-lived ）对象'，执行Minor GC'非常快'，
所以应用不会受到（“Stop the World”）影响。
由于Major GC会检查所有存活的对象，因此会花费更长的时间。应该'尽量减少Major GC'。
因为Major GC会在垃圾回收期间让你的应用反应迟钝，所以'如果'你'有一个'需'要快速响应'的
'应用'发生'多次Major GC'，你'会看到超时错误'。
垃圾'回收时间''取决于垃圾回收策略'。这就是为什么有必要去'监控垃圾收集'和'对垃圾收集进行调优'。
从而'避免'要求'快速响应的应用'出现'超时错误'。
永久代
'永久代'或者“Perm Gen”'包含了'JVM需要的'应用元数据'，这些元数据'描述了'在应用里'使用的类和方法'。
注意，'永久代''不是'Java'堆内存'的'一部分'。
永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在
'full GC时'进行'垃圾收集'。
方法区
'方法区'是'永久代'空间的'一部分'，并用来'存储'类型信息（运行时'常量'和'静态变量'）
和'方法代码'和'构造函数代码'。
内存池
'如果JVM'实现'支持'，JVM内存管理'会'为'创建内存池'，用来为'不变对象''创建对象池'。
'字符串池'就是内存池类型的一个很好的例子。'内存池'可以'属于堆''或'者'永久代'，
这取决于JVM内存管理的实现。
运行时常量池
运行时常量池是每个类常量池的运行时代表。它包含了类的运行时常量和静态方法。
运行时常量池是方法区的一部分。
Java栈内存
Java栈内存用于运行线程。它们包含了方法里的临时数据、堆里其它对象引用的特定数据。
你可以阅读栈内存和堆内存的区别。
Java 堆内存开关
Java提供了大量的内存开关（参数），我们可以用它来设置内存大小和它们的比例。
下面是一些常用的开关：

VM 开关 VM 开关描述
'-Xms 设置JVM启动时堆的初始化大小。'
'-Xmx 设置堆最大值。'
'-Xmn 设置年轻代的空间大小，剩下的为老年代的空间大小。'
'-XX:PermGen 设置永久代内存的初始化大小。'
'-XX:MaxPermGen 设置永久代的最大值。'
'-XX:SurvivorRatio 提供Eden区和survivor区的空间比例'。比如，
如果年轻代的大小为10m并且VM开关是-XX:SurvivorRatio=2，
那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。
-XX:NewRatio 提供年老代和年轻代的比例大小。默认值是2。
大多数时候，上面的选项已经足够使用了。但是如果你还想了解其他的选项，
那么请查看JVM选项官方网页。
Java垃圾回收
Java垃圾回收会找出没用的对象，把它从内存中移除并释放出内存给以后创建的对象使用。
Java程序语言中的一个最大优点是自动垃圾回收，不像其他的程序语言那样需要
手动分配和释放内存，比如C语言。
垃圾收集器是一个后台运行程序。它管理着内存中的所有对象并找出没被引用的对象。
所有的这些未引用的对象都会被删除，回收它们的空间并分配给其他对象。
一个基本的垃圾回收过程涉及三个步骤：
标记：这是第一步。在这一步，垃圾收集器会找出哪些对象正在使用和哪些对象不在使用。
正常清除：垃圾收集器清会除不在使用的对象，回收它们的空间分配给其他对象。
压缩清除：为了提升性能，压缩清除会在删除没用的对象后，把所有存活的对象移到一起。
这样可以提高分配新对象的效率。
简单标记和清除方法存在两个问题：
效率很低。因为大多数新建对象都会成为“没用对象”。
经过多次垃圾回收周期的对象很有可能在以后的周期也会存活下来。
上面简单清除方法的问题在于Java垃圾收集的分代回收的，而且在堆内存里有年轻代
和年老代两个区域。我已经在上面解释了Minor GC和Major GC是怎样扫描对象，
以及如何把对象从一个分代空间移到另外一个分代空间。

Java垃圾回收类型
这里有五种可以在应用里使用的垃圾回收类型。仅需要使用JVM开关就可以在我们的
应用里启用垃圾回收策略。让我们一起来逐一了解：
Serial GC（-XX:+UseSerialGC）：Serial GC使用简单的标记、清除、压缩方法
对年轻代和年老代进行垃圾回收，即Minor GC和Major GC。Serial GC在client模式
（客户端模式）很有用，比如在简单的独立应用和CPU配置较低的机器。
这个模式对占有内存较少的应用很管用。
Parallel GC（-XX:+UseParallelGC）：除了会产生N个线程来进行年轻代的垃圾收集外，
Parallel GC和Serial GC几乎一样。这里的N是系统CPU的核数。
我们可以使用 -XX:ParallelGCThreads=n 这个JVM选项来控制线程数量。
并行垃圾收集器也叫throughput收集器。因为它使用了多CPU加快垃圾回收性能。
Parallel GC在进行年老代垃圾收集时使用单线程。
Parallel Old GC（-XX:+UseParallelOldGC）：和Parallel GC一样。不同之处，
Parallel Old GC在年轻代垃圾收集和年老代垃圾回收时都使用多线程收集。
并发标记清除（CMS）收集器（-XX:+UseConcMarkSweepGC)：CMS收集器也被称为
短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发
进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收
使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿
要求快速响应的应用。可使用 -XX:ParallelCMSThreads=n 
JVM选项来限制CMS收集器的线程数量。
G1垃圾收集器（-XX:+UseG1GC) G1（Garbage First）：
垃圾收集器是在Java 7后才可以使用的特性，它的长远目标时代替CMS收集器。
G1收集器是一个并行的、并发的和增量式压缩短暂停顿的垃圾收集器。
G1收集器和其他的收集器运行方式不一样，不区分年轻代和年老代空间。
它把堆空间划分为多个大小相等的区域。当进行垃圾收集时，
它会优先收集存活对象较少的区域，因此叫“Garbage First”。
你可以在Oracle Garbage-FIrst收集器文档找到更多详细信息。
Java垃圾收集监控
我们可以使用命令行和图形工具来监控监控应用垃圾回收。例如，
我使用Java SE下载页中的一个demo来实验。
如果你想使用同样的应用，可以到Java SE下载页面下载JDK 7和JavaFX演示和示例。
我使用的示例应用是Java2Demo.jar，它位于 jdk1.7.0_55/demo/jfc/Java2D 目录下。
这只是一个可选步骤，你可以运行GC监控命令监控任何Java应用。
我打开演示应用使用的命令是：
1 pankaj@Pankaj:~/Downloads/jdk1.7.0_55/demo/jfc/Java2D$ java -Xmx120m -Xms30m -Xmn10m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar Java2Demo.jar
jsat
可以使用jstat命令行工具监控JVM内存和垃圾回收。标准的JDK已经附带了jstat，
所以不需要做任何额外的事情就可以得到它。
要运行jstat你需要知道应用的进程id，你可以使用 ps -eaf | grep java 命令获取进程id。
123 pankaj@Pankaj:~$ ps -eaf | grep Java2Demo.jar501 9582 11579 0 9:48PM ttys000 0:21.66 /usr/bin/java -Xmx120m -Xms30m -Xmn10m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseG1GC -jar Java2Demo.jar501 14073 14045 0 9:48PM ttys002 0:00.00 grep Java2Demo.jar
从上面知道，我的Java应用进程id是9582。现在可以运行jstat命令了，就像下面展示的一样：
123456789 pankaj@Pankaj:~$ jstat -gc 9582 1000S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT1024.0 1024.0 0.0 0.0 8192.0 7933.3 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8026.5 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8030.0 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8122.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 0.0 0.0 8192.0 8171.2 42108.0 23401.3 20480.0 19990.9 157 0.274 40 1.381 1.6541024.0 1024.0 48.7 0.0 8192.0 106.7 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.6561024.0 1024.0 48.7 0.0 8192.0 145.8 42108.0 23401.3 20480.0 19990.9 158 0.275 40 1.381 1.656
jstat命令的最后一个参数是每个输出的时间间隔。每隔一秒就会打印出内存和垃圾收集数据。
让我们一起来对每一列的意义进行逐一了解：
S0C和S1C：这一列展示了Survivor0和Survivor1区的当前大小（单位KB）。
S0U和S1U：这一列展示了当前Survivor0和Survivor1区的使用情况（单位KB）。
注意：无论任何时候，总会有一个Survivor区是空着的。
EC和EU：这些列展示了Eden区当前空间大小和使用情况（单位KB）。注意：EU的大小一直在增大。
而且只要大小接近EC时，就会触发Minor GC并且EU将会减小。
OC和OU：这些列展示了年老代当前空间大小和当前使用情况（单位KB）。
PC和PU：这些列展示了Perm Gen（永久代）当前空间大小和当前使用情况（单位KB）。
YGC和YGCT：YGC这列显示了发生在年轻代的GC事件的数量。YGCT这列显示了在年轻代进行GC
操作的累计时间。注意：在EU的值由于minor GC导致下降时，同一行的YGC和YGCT都会增加。
FGC和FGCT：FGC列显示了发生Full GC事件的次数。FGCT显示了进行Full GC操作的累计时间。
注意：相对于年轻代的GC使用时间，Full GC所用的时间长很多。
GCT：这一列显示了GC操作的总累计时间。注意：总累计时间是YGCT和FGCT两列所用时间的总
和（GCT=YGCT+FGCT）。
jstat的优点，我们同样可以在没有GUI的远程服务器上运行jstat。
注意：我们是通过 -Xmn10m 选项来指定S0C、S1C和EC的总和为10m的。
Java VisualVM及Visual GC插件
如果你想在GUI里查看内存和GC，那么可以使用jvisualvm工具。Java VisualVM同样是JDK的一部分，
所以你不需要单独去下载。
在终端运行jvisualvm命令启动Java VisualVM程序。一旦启动程序，
你需要从Tools->Plugins选项安装Visual GC插件，就像下面图片展示的。

安装完Visual GC插件后，从左边栏打开应用并把视角转到Visual GC部分。
你将会得到关于JVM内存和垃圾收集详情，如下图所示。

Java垃圾回收调优
Java垃圾回收调优应该是提升应用吞吐量的最后一个选择。
在你发现应用由于长时间垃圾回收导致了应用性能下降、出现超时的时候，
应该考虑Java垃圾收集调优。
如果你在日志里看到 java.lang.OutOfMemoryError: PermGen space错误，
那么可以尝试使用 -XX:PermGen 和 -XX:MaxPermGen JVM选项去监控并增加Perm Gen内存空间。
你也可以尝试使用-XX:+CMSClassUnloadingEnabled并查看使用CMS垃圾收集器的执行性能。
如果你看到了大量的Full GC操作，那么你应该尝试增大老年代的内存空间。
全面垃圾收集调优要花费大量的努力和时间，这里没有一尘不变的硬性调优规则。
你需要去尝试不同的选项并且对这些选项进行对比，从而找出最适合自己应用的方案。
这就是所有的Java内存模型和垃圾回收内容。希望对你理解JVM内存和垃圾收集过程有所帮助。
