面试中经常会问到，'创建'⼀个'线程池'需'要哪些参数'、'线程池'的'工作原理'，
却'很少会问'到'线程池''如何安全关闭'的。

也正是因为⼤家不是很关注这块，即便是⼯作三四年的⼈，
也会有因为'线程池关闭不合理'，导致'应用⽆法正常stop'的情况，还有'出现⼀些报错'的问题。

本篇就以'ThreadPoolExecutor'为例例，来'介绍'下'如何优雅'的'关闭线程池'。

'线程中断'
在'介绍线程池关闭'之'前'，先介绍下'Thread的interrupt'。

在'程序中'，我们是'不能随便中断'⼀个'线程'的，因为'这是'极其'不安全的操作'，
我们'⽆法知道'这个'线程'正运⾏'在什么状态'，'它可能持有某把锁'，强⾏'中断''可能导致''锁不能释放'的问题；
或者'线程可能在操作数据库'，强⾏'中断导致数据''不一致'，从而混乱的问题。
正因此，'Java'⾥'将Thread的stop⽅法''设置为过时'，以'禁⽌⼤家使⽤'。

⼀个'线程''什么时候'可以'退出'呢？当然只有线程自⼰才能知道。

所以我们这⾥要说的'Thread的interrrupt⽅法'，'本质不是'⽤来'中断一个线程'。而'是将线程''设置'⼀个'中断状态'。
当我们'调⽤线程的interrupt'方法，它'有两个作⽤'：

1、如果此'线程''处于阻塞状态'(比如'调⽤了wait方法'，'io等待')，则'会立刻退出阻塞'，
并'抛出InterruptedException异常'，'线程就可以通过捕获'InterruptedException来'做⼀定的处理'，然后'让线程退出'。

2、如果'此线程'正处于'运行之中'，则线程'不受任何影响'，继续运行，'仅仅是线程'的'中断标记被设置为true'。
所以'线程要在适当的位置'通过'调用isInterrupted'方法来'查看自⼰是否被中断'，并'做退出操作'。

注：如果'线程的interrupt'方法'先被调用'，然后'线程调用阻塞方法''进入阻塞'状态，'InterruptedException'异常'依旧会抛出'。
如果'线程捕获InterruptedException异常后'，'继续调用阻塞方法'， 将'不再触发InterruptedException异常'。

线程池的关闭
线程池提供了'两个关闭方法'，'shutdownNow和shuwdown⽅法'。
'shutdownNow'⽅法的解释是：'线程池''拒接收'新提交的'任务'，同时'⽴刻''关闭'线程池，'线程池'里'的任务''不再执行'。
'shutdown'⽅法的解释是：'线程池''拒接收'新提交的'任务'，同时'等待线程池'⾥的'任务执行完毕后''关闭线程池'。

以上的说法虽然没错，但是还有很多的细节问题，比如'调用''shutdown'⽅法后，'正在执⾏'的'任务'的'线程'会做出什么反应？
'正在等待'任务'的线程'又'会做出什么反应'？'线程'在'什么情况'下才'会彻底退出'。
如果不了解这些细节，在关闭线程池时就难免遇到，像线程池关闭不了，关闭线程池出现报错等情况。

再说这些关闭线程池细节问题之前，需要强调一点的是，'调用完shutdownNow和shuwdown'⽅法'后'，并'不代表''线程池'已经'完成关闭操作'，
它'只是异步'的'通知线程池''进行关闭处理'。如果要'同步等待线程池''彻底关闭'后'才继续往下执行'，需'要调⽤awaitTermination⽅法'进'⾏同步等待'。

有了以上介绍，下⾯就结合线程池源码，分别说说这两个线程池关闭方法的⼀一些实现细节。

shutdownNow

我们看⼀下shutdownNow⽅法的源码：

在shutdownNow⽅法里，重要的三句代码我⽤红⾊数字标出来了。第⼀句就是原⼦性的修改线程池的状态为STOP状态(比较简单，我就不贴代码了) ，第三句是将队列里还没有执⾏的任务放到列表里，返回给调用方，第⼆句是遍历线程池⾥的所有⼯作线程，然后调用线程的interrupt方法。如下图：

以上就是shutdownNow⽅法的执⾏逻辑：将线程池状态修改为STOP，然后调⽤线程池⾥的所有线程的interrupt⽅法。

调⽤shutdownNow后，线程池⾥的线程会做如何反应呢？那就要看，线程池⾥的线程正在执⾏的代码逻辑了。其在线程池的runWorker⽅法里(对线程池的执行原理不了解的，请看之前的文章)，其代码如下：

正常情况下，线程池里的线程，就是在这个while循环里不停地执行。其中代码task.run()就是在执⾏我们提交给线程池的任务，如当我们调用shutdownNow  时，task.run()⾥⾯正处于IO阻塞，则会导致报错，如果task.run()⾥正在正常执

⾏，则不受影响，继续执⾏完这个任务。

从上图看得出来，如果getTask()⽅法返回null,也会导致线程的退出。我们再来看看getTask⽅法的实现：

如果我们调⽤shutdownNow⽅法时，线程处于从队列⾥读取任务⽽阻塞中(图中下边的红框)，则会导致抛出InterruptedException异常，但因为异常被捕获，线程将会继续在这个for循环⾥执⾏。

还记得shutdownNow⽅法里将线程修改为STOP状态吧，当执行到上边红框⾥的代码时，由于STOP状态值是⼤于SHUTDOWN状态，STOP也大于等于STOP，不管任务队列是否为空，都会进⼊if语句从而返回null,线程退出。

总结：当我们调用线程池的shutdownNow时，如果线程正在getTask方法中执⾏，则会通过for循环进入到if语句，于是getTask 返回null,从而线程退出。不管线程池⾥是否有未完成的任务。如果线程因为执行提交到线程池里的任务而处于阻塞状态，则会导致报错。（如果任务里没有捕获InterruptedException异常)，否则线程会执行完当前任务，然后通过getTask方法返回为null来退出。

shutdown

我们再来看看shutdown⽅法的源码：

跟shutdownNow类似，只不过它是将线程池的状态修改为SHUTDOWN状态，然后调⽤interruptIdleWorkers方法，来中断空闲的线程。这是interruptIdleWorkers⽅法的实现：

跟shutdownNow⽅法调⽤interruptWorkers⽅法不同的是，interruptIdleWorkers⽅法在遍历线程池⾥的线程时，有一个w.tryLock()加锁判断，只有加锁成功的线程才会被调用interrupt方法。那么什么情况下才能被加锁成功?什么情况下不能被加锁成功呢？这就需要我们继续回到线程执行的runWorker方法。

在上边runWorker方法代码的截图中，我刻意将w.lock()和w.unlock()调用用红框 圈起。其实就是正运行在w.lock和w.unlock之间的线程将因为加锁失败，而不会被调用interrupt方法，换句话说，就是正在执行线程池里任务的线程不会被中断。

不管是被调用了interrupt的线程还是没被调用的线程，什么时候退出呢？，这就要看getTask⽅法的返回是否为null了。

在getTask里的if判断(上文中getTask代码截图中上边红色方框的代码)中，由于线程池被shutdown⽅法修改为SHUTDOWN状态，SHUTDOWN大于等于

SHUTDOWN成⽴没问题，但是SHUTDOWN不⼤于等于STOP状态，所以只有队列为空，getTask方法才会返回null，导致线程退出。

总结：当我们调用线程池的shuwdown方法时，如果线程正在执行线程池里的任务，即便任务处于阻塞状态，线程也不会被中断，⽽是继续执行。如果线程池阻塞等待从队列⾥读取任务，则会被唤醒，但是会继续判断队列是否为空，若不为空，则会继续从队列里读取任务，若为空则线程退出。

优雅的关闭线程池

有了上边对两个关闭线程池方法的了解，相信优雅安全关闭线程池将不再是问题。

我们知道，使⽤shutdownNow⽅法，可能会引起报错，使用shutdown方法可能会导致线程关闭不了。

所以当我们使⽤shutdownNow⽅法关闭线程池时，一定要对任务里进行异常捕获。

当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。

最后，⼀定要记得shutdownNow和shuwdown调用完，线程池并不是⽴刻就关闭了，要想等待线程池关闭，还需调用awaitTermination⽅法来阻塞等待。
