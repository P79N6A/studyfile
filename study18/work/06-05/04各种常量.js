spring 事务-'使用@Transactional' 注解（'事务隔离级别'）

先看下@Transactional可以配制那些参数及以其所代表的意义。

'isolation'
枚举org.springframework.transaction.annotation.Isolation的值
事务'隔离级别'

'noRollbackFor'
Class<? extends Throwable>[]
一组异常类，'遇到'时'不回滚'。默认为{}

'noRollbackForClassName'
Stirng[]
一组异常类名，'遇到'时'不回滚'，默认为{}

'propagation'
枚举org.springframework.transaction.annotation.Propagation的值
事务'传播行为'

'readOnly'
boolean
事务'读写性'

'rollbackFor'
Class<? extends Throwable>[]
一组异常类，'遇'到'时回滚'

rollbackForClassName
Stirng[]
一组异常类名，'遇'到'时回滚'

timeout
超时时间，以秒为单位

value
String
可选的'限定描述'符，'指定'使用的'事务管理器'


'isolation'事务隔离级别,使用时一般如下。
@Transactional(isolation=Isolation.DEFAULT)  
public void method(){}  
isolation的参数有以下'五种'：
1_1、Isolation.'DEFAULT':为数据源的'默认隔离级别'

1_2、isolation=Isolation.'READ_UNCOMMITTED':未授权读取级别
以操作'同一行数据'为前提，'读事务''允许''其他读事务'和'写事务'，
'未提交的写事务''禁止''其他写事务'（但'允许''其他读事务'）。
此隔离级别'可以防止''更新丢失'，
但'不能防止''脏读'、'不可重复读'、'幻读'。此隔离级别可以'通过''“排他写锁”''实现'。

1_3、iIsolation.'READ_COMMITTED':授权读取级别 【我看 准看准做；我做 不准看不准做】
以操作'同一行数据'为前提，'读事务''允许''其他读事务'和'写事务'，
'未提交的写事务''禁止''其他读事务'和'写事务'。
此隔离级别'可以防止''更新丢失'、'脏读'，但'不能防止''不可重复读'、'幻读'。
此隔离级别可以'通过“瞬间共享读锁”'和'“排他写锁”实现'。

1_4、iIsolation.'REPEATABLE_READ':可重复读取级别 【我看 准看不准做；我做 不准看不准做】，串做
以操作'同一行数据'为前提，'读事务''禁止''其他写事务'（但'允许''其他读事务'），
'未提交'的'写事务''禁止'其他'读事务'和'写事务'。
此'隔离级别'可以'防止'更新'丢失'、'脏读'、'不可重复读'，但'不能防止''幻读'。
此隔离级别'可'以'通过“共享读锁”'和'“排他写锁”实现'。

1_5、iIsolation.SERIALIZABLE:序列化级别
提供'严格'的'事务隔离'。它'要求事务''序列化执行'，
'事务''只能''一个接'着'一个'地'执行'，'不能并发执行'。
此隔离级别可以防止更新丢失、脏读、不可重复读、幻读。
如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
对于'多数应用'程序，可以优先考虑'把数据库'系统的'隔离级别''设为Read Committed'。
它能够'避免''更新丢失'、'脏读'，而且具'有较好'的'并发性能'。
'尽管'它'会导致''不可重复读'、'幻读'这些并发问题，
'在'可能出现这类问题的'个别场合'，可以'由应用程序'采用'悲观锁'或'乐观锁'来'控制'。

有关'事务'的'关键字说明'如下，说明如下：

'原子性'(Atomicity)：
'事务''是数据库'的逻辑'工作单位'，它'对数据库'的'修改''要么''全部执行'，'要么''全部不执行'。

'一致性'(Consistemcy)：
'事务前后'，'数据库的状态'都'满足所有'的'完整性约束'。

'隔离性'(Isolation)：
'并发执行'的'事务'是'隔离的'，'一个不影响''一个'。
如果有'两个事务'，运行在'相同的时间内'，'执行相同'的'功能'，
事务的隔离性将'确保每一事务'在系统中认为'只有该事务'在'使用系统'。
这种属性有时称为'串行化'，为了'防止事务操作'间的'混淆'，
必须'串行化'或'序列化'请求，使得'在同一时间''仅有一个请求''用于同一数据'。
通过设置数据库的隔离级别，可以达到不同的隔离效果。

持久性(Durability)：
在'事务完成以后'，该事务所'对数据库'所作的'更改便持久'的'保存在数据库'之中，并不会被回滚。

'更新丢失'：
'两个事务'都'同时更新一行'数据，但是'第二个事务'却中途'失败退出'，
导致对数据的'两个修改''都失效了'。
这是'因为'系统没有执行任何的锁操作，因此'并发事务'并'没有'被'隔离开'来。

'脏读'：
脏读又称无效数据读出。'一个事务''读取''另外一个事务'还'没有提交的数据'叫脏读。
例如：事务'T1修改'了'一行数据'，但是'还没有提交'，
这时候事务'T2读取'了被事务'T1'修改后的数据，之后事务'T1'因为某种原因'Rollback了'，那么事务'T2读取的'数据就'是脏的'。

不可重复读：
不可重复读是指在'同一个事务'内，两个'相同的查询''返回'了'不同的结果'。
例如：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。

幻读：
事务在操作过程中进行'两次查询'，'第二次'查询的'结果''包含'了'第一次'查询中'未出现的数据'或者'缺少'了'第一次'查询中'出现的数据'
例如：系统管理员'A将数据库'中'所有学生的成绩'从具体分数'改为ABCDE等级'，
但是系统'管理员B'就在这个时候'插入'了一条具体'分数的记录'，
当系统管理员'A改结束后'发现还'有一条'记录'没有改过来'，就好像发生了幻觉一样。这就叫幻读。

以上的4种问题（'更新丢失'、'脏读'、'不可重复读'、'幻读'）都和事务的隔离级别有关。通过'设置'事务的'隔离级别'，可以'避免'上述'问题的发生'。