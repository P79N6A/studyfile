PS：'tcpdump是'一个用于'截取网络'分组，并'输出分组内容''的工具'，简单说就'是数据包抓包工具'。
tcpdump凭借强大的功能和灵活的截取策略，使其成为Linux系统下用于网络分析和问题排查的首选工具。

tcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。
tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，
但具备root权限的用户可以直接执行它来获取网络上的信息。
因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。

一、概述
顾名思义，'tcpdump可以将'网络中传送的'数据包的“头”'完全'截获'下来'提供分析'。
它'支持'针对'网络层'、'协议'、'主机'、'网络或端口'的'过滤'，
并'提供'and、or、not等'逻辑语句'来帮助你'去掉无用的信息'。


# tcpdump -vv
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
11:53:21.444591 IP (tos 0x10, ttl  64, id 19324, offset 0, flags [DF], proto 6, length: 92) asptest.localdomain.ssh > 192.168.228.244.1858: P 3962132600:3962132652(52) ack 2726525936 win 1266
asptest.localdomain.1077 > 192.168.228.153.domain: [bad udp cksum 166e!]  325+ PTR? 244.228.168.192.in-addr.arpa. (46)
11:53:21.446929 IP (tos 0x0, ttl  64, id 42911, offset 0, flags [DF], proto 17, length: 151) 192.168.228.153.domain > asptest.localdomain.1077:  325 NXDomain q: PTR? 244.228.168.192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123)
11:53:21.447408 IP (tos 0x10, ttl  64, id 19328, offset 0, flags [DF], proto 6, length: 172) asptest.localdomain.ssh > 192.168.228.244.1858: P 168:300(132) ack 1 win 1266
347 packets captured
1474 packets received by filter
745 packets dropped by kernel

'不带参数'的tcpdump会'收集'网络中'所有的信息包头'，'数据量巨大'，'必须过滤'。

二、选项介绍
'-A' 以'ASCII格式打印'出'所有分组'，并将'链路层的头''最小化'。

'-c' 在'收到指定的数量'的分组后，tcpdump'就会停止'。

'-C' 在'将'一个'原始分组''写入文件之前'，'检查文件'当前的'大小是否超过'了参数'file_size'
中指定的大小。如果'超过了'指定大小，则'关闭'当前'文件'，然后在'打开'一个'新的文件'。
参数 'file_size' 的'单位是兆字节'（是'1,000,000'字节，而'不是1,048,576'字节）。

'-d' 将'匹配信息包'的代码以人们能够理解的'汇编格式给出'。

'-dd' 将'匹配信息包'的代码以'c语言程序段'的'格式给出'。

'-ddd' 将'匹配信息包'的代码以'十进制'的'形式给出'。

'-D' 打印出'系统中'所有可以'用tcpdump截包'的'网络接口'。

'-e' 在'输出行'打印出'数据链路层'的'头部信息'。

'-E' 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。

'-f' 将'外部的Internet地址'以'数字的形式打印'出来。

'-F' 从'指定的文件中读取'表达式，忽略命令行中给出的表达式。

'-i' '指定监听'的'网络接口'。

'-l' 使'标准输出''变为''缓冲行形式'，可以'把数据导出到文件'。

'-L' '列出网络接口'的'已知数据链路'。

'-m' 从'文件module'中'导入SMI MIB模块'定义。'该参数''可以'被使用多次，以'导入多个MIB模块'。

'-M' 如果'tcp报文'中'存在TCP-MD5选项'，则需'要用secret'作为'共享的验证码'用于'验证TCP-MD5''选选项摘要'（详情可参考RFC 2385）。

'-b' 在'数据-链路层'上'选择协议'，包括'ip、arp、rarp、ipx'都是这一层的。

'-n' '不把网络地址''转换成名字'。

'-nn' 不进行端口名称的转换。

'-N' '不输出'主机名中的'域名部分'。例如，‘nic.ddn.mil‘只输出’nic‘。

'-t' 在'输出的每一行''不打印时间戳'。

'-O' '不运行分组'分组'匹配'（packet-matching）代码优化程序。

'-P' '不将网络接口''设置成混杂模式'。

'-q' '快速输出'。只'输出较少'的'协议信息'。

'-r' '从指定'的'文件'中'读取包'(这些包一般通过-w选项产生)。

'-S' 将'tcp的序列号'以'绝对值形式输出'，而不是相对值。

'-s' 从'每个分组'中'读取最开始'的'snaplen个字节'，而不是默认的68个字节。

'-T' 将'监听到的包'直接'解释为指定'的'类型'的'报文'，'常见的类型'有'rpc''远程'过程'调用'）和'snmp'（'简单'网络'管理协议'；）。

'-t' '不'在每一行中'输出时间戳'。

'-tt' 在'每一行'中'输出非格式化的时间戳'。

'-ttt' 输出'本行和前面一行'之间的'时间差'。

'-tttt' 在'每一行中输出'由'date处理'的'默认格式'的'时间戳'。

'-u' 输出'未解码'的'NFS句柄'。

'-v' '输出'一个'稍微详细'的'信息'，例如在'ip包'中可以'包括ttl'和'服务类型'的信息。

'-vv' '输出详细'的'报文信息'。

'-w' 直接'将分组写入文件'中，而不是'不分析'并'打印'出来。

三、'tcpdump'的'表达式'介绍
表达式'是'一个'正则表达式'，tcpdump利'用它'作为'过滤报文'的条件，如果一个'报文''满足''表达式'的条件，
则这个'报文'将会'被捕获'。如果没有给出任何条件，则网络上所有的信息包 将会被截获。

在表达式中一般如下'几种类型'的'关键字：'
'第一种是'关于'类型'的'关键字'，主要'包括host'，'net'，'port'，例如 'host 210.27.48.2'， 
'指明'210.27.48.2是一台'主机'，'net 202.0.0.0''指明'202.0.0.0是一个'网络地址'，
'port 23' '指明端口'号是23。如果没有指定类型，缺省的类型是host。

'第二种'是'确定传输方向'的关键字，主要'包括src，dst，dst or src，dst and src'， 
这些关键字指明了传输的方向。举例说明，'src 210.27.48.2' ，
'指明ip'包中'源地址'是 210.27.48.2 ， 'dst net 202.0.0.0' '指明目的网络地址'是202.0.0.0。
如果没有指明 方向关键字，则'缺省是src or dst'关键字。

'第三种'是'协议'的'关键字'，主要'包括fddi，ip，arp，rarp，tcp，udp'等类型。Fddi指明
是在FDDI (分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似的源地址和目的地址，
所以可以将fddi协议包当作ether的包进行处理和分析。 
'其他'的几个'关键字'就是'指明'了'监听的包'的'协议内容'。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。

除了这三种类型的关键字之外，'其他重要'的'关键字'如下：'gateway， broadcast，less， greater'，
还有'三种逻辑运算'，取非运算是 ‘not ‘ ‘! ‘， 与运算是’and’，’&&’;或运算是’or’ ，’&#124;&#124;’； 
这些关键字可以组合起来构成强大的组合条件来满足人们的需要。

-----------------------------------------------------------------------------------------------------------------------------------
一般情况下，'非HTTP协议'的'网络分析'，在'服务器端用tcpdump'比'较多'，在'客户端用wireshark'比'较多'，两个抓包软件的'语法是一样的'。

一、基本语法
1.1、'过滤主机'
抓取所有经过eth1，'目的或源地址'是192.168.1.1的网络数据
tcpdump -i eth1 host 192.168.1.1
'指定源地址'
tcpdump -i eth1 src host 192.168.1.1
'指定目的地址'
tcpdump -i eth1 dst host 192.168.1.1
1.2、'过滤端口'
抓取所有经过eth1，'目的或源端口'是25的网络数据
tcpdump -i eth1 port 25
'指定源端口'
tcpdump -i eth1 src port 25
'指定目的端口'
tcpdump -i eth1 dst port 25
1.3、'网络过滤'
tcpdump -i eth1 net 192.168
tcpdump -i eth1 src net 192.168
tcpdump -i eth1 dst net 192.168
1.4、'协议过滤'
tcpdump -i eth1 arp
tcpdump -i eth1 ip
tcpdump -i eth1 tcp
tcpdump -i eth1 udp
tcpdump -i eth1 icmp
1.5、'常用表达式'
非 : ! or "not" (去掉双引号)  
且 : && or "and"  
或 : || or "or"
抓取'所有经过eth1'，'目的地址'是'192.168.1.254'或192.168.1.200'端口是80'的'TCP数据'
tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))'
抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据
tcpdump -i eth1 '((icmp) and ((ether dst host 00:01:02:03:04:05)))'
抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据
tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))'


tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 119.123.71.234) or (dst host 192.168.1.200)))'
tcpdump -i eth1 '((tcp) and ((dst host 119.123.71.234) or (dst host 192.168.1.200)))' -s 0 -w ehuandianTcp 

tcpdump -i -d eth1 '((tcp) and (dst host 119.123.71.234))' -s 0 -w ehuandianTcp1 

tcpdump -i eth1 '((tcp) and (dst host 119.123.71.234))' -w ehuandianTcp1 -ddd

二、'高级包头过滤'
首先'了解''如何从包头''过滤'信息

proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排）
proto[x:y] & z = 0  : proto[x:y]和z的与操作为0
proto[x:y] & z !=0  : proto[x:y]和z的与操作不为0
proto[x:y] & z = z  : proto[x:y]和z的与操作为z
proto[x:y] = z      : proto[x:y]等于z
操作符 : >, <, >=, <=, =, !=

2.1、'IP头'
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Version|  IHL  |Type of Service|          Total Length         |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Identification        |Flags|      Fragment Offset    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Time to Live |    Protocol   |         Header Checksum       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       Source Address                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Destination Address                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Options                    |    Padding    | <-- optional
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                            DATA ...                           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
本文'只针对IPv4'。

2.2、'IP选项设置'了吗？
“一般”的'IP头'是'20字节'，但'IP头有选项设置'，'不能直接'从'偏移21字节'处'读取'数据。
'IP头'有个'长度字段''可以知道头长度'是否大于20字节。
 +-+-+-+-+-+-+-+-+
 |Version|  IHL  |
 +-+-+-+-+-+-+-+-+
通常'第一个字节'的'二进制值'是：'01000101'，'分成两个部分'：

0100 = 4 '表示IP版本' 0101 = 5 '表示IP头32 bit的块数'，5 x 32 bits = 160 bits or 20 bytes

如果'第一字节''第二部分的值大于5'，那么表示'头有IP选项'。

下面介绍两种过滤方法（第一种方法比较操蛋，可忽略）：

a. 比较第一字节的值是否大于01000101，这可以判断IPv4带IP选项的数据和IPv6的数据。

01000101十进制等于69，计算方法如下（小提示：用计算器更方便）

0 : 0  \
1 : 2^6 = 64 \ 第一部分 (IP版本)
0 : 0   /
0 : 0  /
-
0 : 0  \
1 : 2^2 = 4  \ 第二部分 (头长度)
0 : 0   /
1 : 2^0 = 1 /
64 + 4 + 1 = 69
如果设置了IP选项，那么第一自己是01000110（十进制70），过滤规则：

tcpdump -i eth1 'ip[0] > 69'
IPv6的数据也会匹配，看看第二种方法。

b. 位操作

0100 0101 : 第一字节的二进制
0000 1111 : 与操作
<=========
0000 0101 : 结果

正确的过滤方法

tcpdump -i eth1 'ip[0] & 15 > 5'
或者

tcpdump -i eth1 'ip[0] & 0x0f > 5'
'2.3、分片标记'
当发送端的MTU大于到目的路径链路上的MTU时就会被分片，这段话有点拗口，权威的请参考《TCP/IP详解》。
唉，32借我的书没还，只能凑合写，大家记得看书啊。

分片信息在IP头的第七和第八字节：
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Flags|      Fragment Offset    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Bit 0: 保留，必须是0
Bit 1: (DF) 0 = 可能分片, 1 = 不分片
Bit 2: (MF) 0 = 最后的分片, 1 = 还有分片

Fragment Offset字段只有在分片的时候才使用。

要抓带DF位标记的不分片的包，第七字节的值应该是：

01000000 = 64

tcpdump -i eth1 'ip[6] = 64'
2.4、'抓分片包'
匹配MF，分片包
tcpdump -i eth1 'ip[6] = 32'
最后分片包的开始3位是0，但是有Fragment Offset字段。

'匹配分片'和'最后分片'
tcpdump -i eth1 '((ip[6:2] > 0) and (not ip[6] = 64))'
测试分片可以用下面的命令：
ping -M want -s 3000 192.168.1.1

2.5、匹配小TTL
TTL字段在第九字节，并且正好是完整的一个字节，TTL最大值是255，二进制为11111111。

可以用下面的命令验证一下：

$ ping -M want -s 3000 -t 256 192.168.1.200
ping: ttl 256 out of range
 +-+-+-+-+-+-+-+-+
 |  Time to Live |
 +-+-+-+-+-+-+-+-+
在网关可以用下面的命令看看网络中谁在使用traceroute
tcpdump -i eth1 'ip[8] < 5'
2.6、抓大于X字节的包
大于600字节
tcpdump -i eth1 'ip[2:2] > 600'
2.7、'更多的IP过滤'
首先还是需要知道TCP基本结构，再次推荐《TCP/IP详解》，卷一就够看的了，避免走火入魔。

TCP头
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |          Source Port          |       Destination Port        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Sequence Number                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Acknowledgment Number                      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Data |       |C|E|U|A|P|R|S|F|                               |
 | Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |
 |       |       |R|E|G|K|H|T|N|N|                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |           Checksum            |         Urgent Pointer        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Options                    |    Padding    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                             data                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
'抓取源端口大于1024'的'TCP数据包'
tcpdump -i eth1 'tcp[0:2] > 1024'
匹配TCP数据包的特殊标记
TCP标记定义在TCP头的第十四个字节
 +-+-+-+-+-+-+-+-+
 |C|E|U|A|P|R|S|F|
 |W|C|R|C|S|S|Y|I|
 |R|E|G|K|H|T|N|N|
 +-+-+-+-+-+-+-+-+
重复一下TCP三次握手，两个主机是如何勾搭的：

源发送SYN
目标回答SYN, ACK
源发送ACK
没女朋友的童鞋要学习一下：
1. MM，你的手有空吗？--
2. 有空，你呢？\~~
3. 我也有空 *_*

失败的loser是酱紫的：
1. MM，这是你掉的板砖吗？(SYN) ￣▽￣
2. 不是，找拍啊？(RST-ACK) ˋ﹏ˊ

只抓SYN包，第十四字节是二进制的00000010，也就是十进制的2
tcpdump -i eth1 'tcp[13] = 2'
抓SYN, ACK （00010010 or 18）
tcpdump -i eth1 'tcp[13] = 18'
抓SYN或者SYN-ACK
tcpdump -i eth1 'tcp[13] & 2 = 2'
用到了位操作，就是不管ACK位是啥。

抓PSH-ACK
tcpdump -i eth1 'tcp[13] = 24'
抓所有包含FIN标记的包（FIN通常和ACK一起，表示幽会完了，回见）
tcpdump -i eth1 'tcp[13] & 1 = 1'
抓RST（勾搭没成功，伟大的greatwall对她认为有敏感信息的连接发RST包，典型的棒打鸳鸯）
tcpdump -i eth1 'tcp[13] & 4 = 4'
下图详细描述了TCP各种状态的标记，方便分析。

tcp_state_machine.jpg

2.8、大叔注
tcpdump考虑了一些数字恐惧症者的需求，提供了部分常用的字段偏移名字：

icmptype (ICMP类型字段)
icmpcode (ICMP符号字段)
tcpflags (TCP标记字段)

ICMP类型值有：

icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply

TCP标记值：

tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg

这样上面按照TCP标记位抓包的就可以写直观的表达式了：

只抓SYN包
tcpdump -i eth1 'tcp[tcpflags] = tcp-syn'
抓SYN, ACK
tcpdump -i eth1 'tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack != 0'
2.9、抓SMTP数据
tcpdump -i eth1 '((port 25) and (tcp[(tcp[12]>>2):4] = 0x4d41494c))'
抓取数据区开始为"MAIL"的包，"MAIL"的十六进制为0x4d41494c。

2.10、抓HTTP GET数据
tcpdump -i eth1 'tcp[(tcp[12]>>2):4] = 0x47455420'
"GET "的十六进制是47455420

2.11、抓SSH返回
tcpdump -i eth1 'tcp[(tcp[12]>>2):4] = 0x5353482D'
"SSH-"的十六进制是0x5353482D

tcpdump -i eth1 '(tcp[(tcp[12]>>2):4] = 0x5353482D) and (tcp[((tcp[12]>>2)+4):2] = 0x312E)'
抓老版本的SSH返回信息，如"SSH-1.99.."

三、大叔注
如果是'为了查看数据内容'，建议'用tcpdump -s 0 -w filename把数据包'都'保存下来'，然后'用wireshark的Follow TCP Stream/Follow UDP Stream'来'查看整个会话的内容'。

'-s 0'是'抓取完整''数据包'，否则'默认只抓68字节'。

另外，用'tcpflow'也'可以方便'的'获取TCP会话内容'，支持tcpdump的各种表达式。

3.1、UDP头
  0      7 8     15 16    23 24    31
 +--------+--------+--------+--------+
 |     Source      |   Destination   |
 |      Port       |      Port       |
 +--------+--------+--------+--------+
 |                 |                 |
 |     Length      |    Checksum     |
 +--------+--------+--------+--------+
 |                                   |
 |              DATA ...             |
 +-----------------------------------+
抓'DNS请求数据'
tcpdump -i eth1 udp dst port 53
3.2、其他
'-c参数'对于'运维人员'来说也'比较常用'，因为'流量比较大'的'服务器'，'靠人工CTRL+C'还是'抓的太多'，
甚至'导致服务器''宕机'，于是可以'用-c参数''指定抓多少个包'。

time tcpdump -nn -i eth0 'tcp[tcpflags] = tcp-syn' -c 10000 > /dev/null
上面的命令计算抓10000个SYN包花费多少时间，可以判断访问量大概是多少。

