1. 【强制】'避免''通过一个类'的'对象''引用访问此类'的'静态变量''或静态方法'，
'无谓增加''编译器解析成本'，直接'用类名来访问即可'。

2. 【强制】'所有的覆写方法'，必'须加@Override 注解'。
说明：'getObject()'与'get0bject()'的问题。'一个是字母的 O'，'一个是数字的 0'，'加@Override'
'可'以'准确判断''是否覆盖成功'。另外，如果'在抽象类'中'对方法签名''进行修改'，'其实现类会'
'马上编译报错'。

3. 【强制】'相同'参数'类型'，'相同''业务含义'，'才可以使用' Java 的'可变参数'，'避免使用 Object'。
说明： '可变参数'必'须放置'在'参数列表'的'最后'。 （提倡同学们尽量不用可变参数编程）
正例： 
	public List<User> listUsers(String type, Long... ids) {...}
	
4. 【强制】'外部'正在'调用''或者二方库''依赖的接口'，'不允许修改''方法签名'，'避免''对接口调用方'
'产生影响'。'接口过时''必须加@Deprecated 注解'，并'清晰'地'说明''采用的新接口'或者'新服务'是什么。

5. 【强制】'不能使用''过时的类'或'方法'。
说明： 'java.net.URLDecoder' 中的方法 'decode(String encodeStr)' 这个方法'已经过时'，应
该'使用双参数' 'decode(String source, String encode)'。接口提供方既然明确是过时接口，
那么有义务同时提供新的接口； 作为调用方来说，有义务去考证过时方法的新实现是什么。

6. 【强制】 'Object' 的 'equals' 方法容易'抛空指针'异常，应'使用常量'或'确定有值的对象'来'调用'equals。
正例： "test".equals(object);
反例： object.equals("test");
说明： 推荐使用 'java.util.Objects'#'equals'（JDK7 引入的工具类）

7. 【强制】'所有'的'相同类型'的'包装类''对象'之间'值的比较'，全部'使用 equals' 方法比较。
说明： 对于 'Integer var = ?' '在-128 至 127 范围'内的赋值， 'Integer 对象'是在
IntegerCache.cache 产生，'会复用已有对象'，这个区间内的 'Integer 值'可以'直接使用=='进行
判断，但是'这个区间之外'的所有数据，都'会在堆上产生'，并'不会复用已有对象'，这是一个大坑，
推荐'使用 equals 方法进行判断'。

8. 关于'基本数据类型'与'包装数据类型'的'使用标准'如下：
1） 【强制】 '所有'的 'POJO 类''属性'必须'使用包装数据类型'。
2） 【强制】 'RPC 方法'的'返回值'和'参数'必须'使用包装数据类型'。
3） 【推荐】 '所有的局部变量'使'用基本数据类型'。
说明： 'POJO 类属性''没有初值'是'提醒使用者'在'需要使用时'，必须'自己显式'地进行'赋值'，任何
NPE 问题，或者入库检查，都由使用者来保证。
正例： '数据库'的'查询结果'可能'是 null'，因为'自动拆箱'，用'基本数据类型接收''有 NPE 风险'。
反例： 比如'显示成交总额'涨跌情况，'即正负 x%'， 'x '为'基本数据类型'，'调用的 RPC 服务'，调用
'不成功时'，'返回'的是默认值，页面'显示为 0%'，这'是不合理的'，应该显示成中划线。所以包装
数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。

9. 【强制】'定义 DO/DTO/VO' 等 'POJO 类'时，'不要设定'任何属性'默认值'。
反例：POJO 类的 'gmtCreate' '默认值'为 'new Date()'， 但是这个'属性在数据提取'时并'没有置入具体值'，
在'更新其它字段'时又'附带更新'了'此字段'，导致创建时间被修改成当前时间。

10. 【强制】'序列化类'新增属性时，请'不要修改 serialVersionUID' 字段，'避免反序列失败'； 
'如果''完全不兼容''升级'，'避免反序列化'混乱，那么'请修改 serialVersionUID 值'。
说明： 注意'serialVersionUID''不一致会''抛出序列化运行时异常'。

11. 【强制】'构造方法里面''禁止加入'任何'业务逻辑'，如果'有初始化逻辑'，请'放在 init 方法中'。

12. 【强制】'POJO 类'必'须写 toString 方法'。使用 IDE 中的工具： source> generate toString
时，如果'继承'了另一个'POJO 类'，注意'在前面加'一下 'super.toString。'
说明： '在方法执行抛出异常时'，可以直接'调用 POJO 的 toString()'方法'打印其属性值'，便于排
查问题。

13.【强制】'禁止在 POJO 类中'，'同时存在'对应'属性 xxx' '的 isXxx()和 getXxx()方法'。
说明： '框架'在'调用属性' xxx 的'提取方法时'，并'不能确定'哪个方法一定是被'优先调用'到。

14.【推荐】使'用索引访问'用 String 的 'split' 方法'得到的数组'时，需'做最后一个分隔符'
后'有无内容的检查'，'否则'会有'抛 IndexOutOfBoundsException 的风险'。
说明：
	String str = "a,b,c,,";
	String[] ary = str.split(",");
	// 预期大于 3，结果是 3
	System.out.println(ary.length);
	
15.【推荐】当'一个类'有'多个构造方法'，或者'多个同名方法'，这些'方法应该按顺序''放置在一起'，
'便于阅读'，此条规则优先于第 16 条规则。

16.【推荐】 类内方法'定义的顺序'依次是：'公有方法'或'保护方法' > '私有方法' > 'getter/setter'方法。
说明： '公有方法'是'类的调用者'和'维护者''最关心的方法'，首屏展示最好； '保护方法虽然只是子类'
关心，'也可能是“模板设计模式”下的核心方法'； 而'私有方法外部'一般'不需要特别关心'，是一个
黑盒实现； 因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。

17. 【推荐】'setter方法中'，'参数名称与类成员变量名称一致'，' this.成员名 = 参数名'。在
getter/setter 方法中， '不要增加业务逻辑'，增加排查问题的难度。
反例：
public Integer getData() {
	if (condition) {
		return this.data + 100;
	} else {
		return this.data - 100;
	}
}

18. 【推荐】'循环体内'，'字符串的连接方式'，使'用 StringBuilder' 的 'append 方法'进行扩展。
说明： 下例中， 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，
然后进行'append操作'，最后'通过 toString' 方法'返回 String 对象'，造成内存资源浪费。
反例：
String str = "start";
for (int i = 0; i < 100; i++) {
	str = str + "hello";
}

19. 【推荐】'final''可以声明类'、'成员变量'、'方法'、以及'本地变量'，下列情况使用 final 关键字：
1） '不允许被继承'的'类'，如：String类。
2） '不允许'修改'引用的域对象'。
3） '不允许'被'重写的方法'，如： POJO 类的 setter 方法。
4） '不允许'运行过程中'重新赋值'的'局部变量'。
5） '避免'上下文'重复''使用'一个'变量'，使用'final'描述'可'以强制'重新定义'一个'变量'，方便'更好'地'进行重构'。

20. 【推荐】'慎用 Object 的 clone' 方法来'拷贝对象'。
说明： 对象的 'clone 方法''默认'是'浅拷贝'，若想'实现深拷贝'需'要重写 clone' 方法实现域对象的
深度遍历式拷贝。

21. 【推荐】'类成员'与'方法访问''控制从严'：
1） 如果'不允许外部'直接'通过 new '来'创建对象'，那么'构造方法'必须'是 private'。
2） '工具类''不允许'有 'public' 或 'default' '构造方法'。
3） '类非 static' '成员变量'并且'与子类共享'，'必须是 protected'。
4） '类非 static' '成员变量'并且'仅在本类使用'，'必须是 private'。
5） '类 static' '成员变量'如果'仅在本类使用'，'必须是 private'。
6） '若是 static 成员变量'， '考虑是否为 final'。
7） '类成员方法'只'供类内部调用'，必须是 'private'。
8） '类成员方法'只'对继承类公开'，那么限制为 'protected'。
说明： 任何'类'、'方法'、'参数'、'变量'，严控'访问范围'。'过于宽泛的'访问'范围'，'不利于模块''解耦'。
思考：如果是'一个 private' 的方法，'想删除就删除'，可是'一个 public' 的 service 成员方法或
成员变量，'删除一下'，不得'手心冒点汗'吗？变量像自己的小孩，'尽量''在自己'的'视线内'，变量作
用域太大， '无限制的到处跑'，那么'你会担心的'。