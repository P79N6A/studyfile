MYSQL开发性能研究——批量插入的优化措施
一、我们遇到了什么问题
在标准SQL里面，我们通常会写下如下的SQL insert语句。
1 INSERT INTO TBL_TEST (id) VALUES(1);
 
很显然,在MYSQL中，这样的方式也是可行的。
但是'当'我们'需要批量插入数据的时候'，'这样的语句'却'会出现性能问题'。
例如说，如果'有需要插入100000条数据'，那么'就需要有100000条insert语句'，
每一句都需要提交到关系引擎那里去解析，
优化，然后才能够到达存储引擎做真的插入工作。

正是'由于性能的瓶颈问题'，'MYSQL官方文档'也就'提到了使用批量化插入的方式'，
也就是'在一句INSERT语句里'面'插入多个值'。即，

INSERT INTO TBL_TEST (id) VALUES (1), (2), (3)
'这样'的做法确实也'可以起到加速批量插入的功效'，原因也不难理解，
由于'提交到服务器的INSERT语句少了'，网络'负载少了'，
最主要的是'解析和优化的时间''看似增多'，但是'实际上作用的数据行'却实打实地'多了'。
所以整体性能得以提高。根据网上的一些说法，这种方法可以提高几十倍。

然而，我在网上也看到过另外的几种方法，比如说'预处理SQL'，比如说'批量提交'。
那么这些方法的性能到底如何？本文就会对这些方法做一个比较。

二、比较环境和方法
我的'环境'比较苦逼，基本上就是一个落后的虚拟机。'只有2核'，'内存为6G'。
操作系统是SUSI Linux，'MYSQL版本是5.6.15'。

可以想见，这个机子的性能导致了我的TPS一定非常低，
所以下面的所有数据都是没有意义的，但是趋势却不同，
它'可以看出'整个'插入的性能走向'。

由于业务特点，我们所使用的表非常大，共有195个字段，
且写满（每个字段全部填满，包括varchar）大致会有略小于4KB的大小，
而通常来说，一条记录的大小也有3KB。

由于'根据'我们的'实际经验'，我们很'肯定的是'，
通过在一个事务中提交大量INSERT语句可以大幅度提高性能。
所以下面的所有测试都是建立在每插入5000条记录提交一次的做法之上。

最后需要说明的是，下面所有的测试都是通过使用MYSQL C API进行的，
并且使用的是INNODB存储引擎。

三、比较方法
 
理想型测试（一）——方法比较
目的：找出理想情况下最合适的插入机制

关键方法：

1. 每个进/线程按主键顺序插入

2. 比较不同的插入方法

3. 比较不同进/线程数量对插入的影响

image

*“普通方法”指的是一句INSERT只插入一个VALUE的情况。

*“预处理SQL”指的是使用预处理MYSQL C API的情况。

* “多表值SQL(10条）”是使用一句INSERT语句插入10条记录的情况。
为什么是10条？后面的验证告诉了我们这样做性能最高。

结论，很显然，从三种方法的趋势上来看，多表值SQL(10条）的方式最为高效。

理想型测试（二）——多表值SQL条数比较
 
image

很显然，在数据量提高的情况下，每条INSERT语句插入10条记录的做法最为高效。

理想型测试（三）——连接数比较
image

image

结论：在2倍与CPU核数的连接和操作的时候，性能最高

一般性测试—— 根据我们的业务量进行测试
目的：最佳插入机制适合普通交易情况？

关键方法：

1. 模拟生产数据(每条记录约3KB)

2. 每个线程主键乱序插入

image

很显然，如果是根据主键乱序插入的话，性能会有直线下降的情况。
这一点其实和INNODB的内部实现原理所展现出来的现象一致。
但是仍然可以肯定的是，多表值SQL(10条）的情况是最佳的。

压力测试
目的：最佳插入机制适合极端交易情况？

关键方法：

1. 将数据行的每一个字段填满（每条记录约为4KB）

2. 每个线程主键乱序插入


结果和我们之前的规律类似，性能出现了极端下降。
并且这里验证了随着记录的增大
（可能已经超过了一个page的大小，毕竟还有slot和page head信息占据空间），
会有page split等现象，性能会下降。

四、结论
根据上面的测试，以及我们对INNODB的了解，我们可以得到如下的结论。

•采用顺序主键策略（例如自增主键，或者修改业务逻辑，让插入的记录尽可能顺序主键）

•采用多值表（10条）插入方式最为合适

•将进程/线程数控制在2倍CPU数目相对合适

五、附录
我发现网上很少有完整的针对MYSQL 预处理SQL语句的例子。这里给出一个简单的例子。
