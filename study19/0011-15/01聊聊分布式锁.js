1.背景
对于锁大家肯定不会陌生，在'Java'中'synchronized关键字'和'ReentrantLock'
'可重入锁'在我们的'代码中''是经常见的'，
一般'我们用其在多线程环境中''控制对资源的并发访问'，但是'随着分布式的快速发展'，
'本地的加锁'往往'不能满足'我们的'需要'，
'在'我们的'分布式环境中'上面'加锁的方法'就'会失去作用'。
于是'人们为了在分布式环境中'也能'实现本地锁'的'效果'，也是纷纷各出其招，
今天让我们来聊一聊一般'分布式锁''实现的套路'。

2.'分布式锁'
2.1为何需要分布式锁
Martin Kleppmann是英国剑桥大学的分布式系统的研究员，
之前和Redis之父Antirez进行过关于RedLock(红锁，后续有讲到)是否安全的激烈讨论。
'Martin认为'一般'我们使用分布式锁''有两个场景':

'效率':使'用分布式锁''可以避免不同节点''重复相同的工作'，这些工作会浪费资源。
比如用户付了钱之后有可能不同节点会发出多封短信。

'正确性':'加分布式锁'同样'可以避免''破坏正确性的发生'，
如果'两个节点''在同一条数据上面操作'，
比'如多个节点'机器'对同一个订单操作不同的流程'
有'可能会导致''该笔订单最后状态''出现错误'，
造成损失。

2.2'分布式锁的'一些'特点'
当我们'确定了'在'不同节点'上'需要分布式锁'，
'那么'我们'需要了解分布式锁''到底'应'该有哪些特点':

'互斥性':'和'我们'本地锁一样''互斥性''是最基本'，
'但是分布式锁''需要保证''在不同节点的不同线程''的互斥'。

'可重入性':'同一个节点上的''同一个线程''如果获取了锁之后''那么也可以''再次获取这个锁'。

'锁超时':'和本地锁一样''支持锁超时'，'防止死锁'。

'高效'，'高可用':'加锁和解锁''需要高效'，'同时'也需'要保证高可用''防止分布式锁失效'，
'可以增加降级'。

'支持阻塞'和'非阻塞':和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。

'支持公平锁'和'非公平锁'(可选):'公平锁'的意思是'按照请求加锁的顺序获得锁'，
'非公平锁'就相反'是无序的'。这个一般来说实现的比较少。

2.3'常见的分布式锁'
我们了解了一些特点之后，我们一般'实现分布式锁''有以下几个方式':
'MySql'
'Zk'
'Redis'
'自研分布式锁':如谷歌的'Chubby'。

下面分开介绍一下这些分布式锁的'实现原理'。
3'Mysql分布式锁'
首先来说一下'Mysql分布式锁'的'实现原理'，相对来说这个比较容易理解，
毕竟数据库和我们开发人员在平时的开发中息息相关。
对于分布式锁我们可以'创建一个锁表':

前面我们所说的'lock()','trylock(long timeout)','trylock()'这几个方法可以用下面的伪代码实现。

3.1 'lock'()
'lock''一般是''阻塞式的获取锁'，'意思就是''不获取到锁誓不罢休'，
那么我们'可以写一个死循环'来'执行其操作:'

'mysqlLock.lcok''内部是一个sql','为了达到可重入锁的效果'那么我们'应该先进行查询'，
'如果有值'，'那么''需要比较node_info''是否一致'，
这里的'node_info''可以用机器IP''和线程名字来表示'，'如果一致'那么'就加可重入锁count的值'，
'如果不一致'那么'就返回false'。'如果没有值'那么'直接插入一条数据'。伪代码如下:

'需要注意的是''这一段代码''需要加事务'，'必须要保证''这一系列操作''的原子性'。

3.2 'tryLock()和tryLock(long timeout)'
'tryLock'()'是非阻塞获取锁'，如果'获取不到'那么就'会马上返回'，代码可以如下:

'tryLock'(long timeout)实现如下:

'mysqlLock.lock''和上面一样'，但是'要注意的是select … for update'这个'是阻塞的获取行锁'，
如果'同一个资源''并发量较大'还是'有可能''会退化成阻塞'的'获取锁'。

3.3 'unlock'()
'unlock的话'如果'这里的count为1'那么'可以删除'，如果'大于1'那么'需要减去1'。

3.4 '锁超时'
我们'有可能'会'遇到我们的机器节点挂了'，那么'这个锁''就不会得到释放'，
我们'可以启动''一个定时任务'，'通过计算'一般我们'处理任务的一般的时间'，
'比如是5ms'，那么我们'可以稍微扩大一点'，
'当这个锁''超过20ms没有被释放'我们'就可以认定是节点挂了''然后将其直接释放'。

3.5 Mysql小结
适用场景: 'Mysql分布式锁'一般'适用于资源不存在数据库'，
'如果数据库存在''比如订单'，那么'可以直接对这条数据''加行锁'，
'不需要'我们上面'多的繁琐的步骤'，比'如一个订单'，
那么我们可以用'select * from order_table where id = "xxx" for update'进行'加行锁'，
那么其他的事务就不能对其进行修改。

优点:'理解起来简单'，'不需要维护额外'的'第三方中间件'(比如Redis,Zk)。

缺点:虽然'容易理解'但是'实现起来较为繁琐'，需'要自己考虑锁超时'，'加事务等等'。
'性能局限于数据库'，一般对比缓存来说'性能较低'。对于'高并发的场景'并'不是很适合'。

3.6 '乐观锁'
前面我们介绍的都是悲观锁，这里想额外提一下乐观锁，
在我们实际'项目中'也是'经常实现乐观锁'，'因为'我们'加行锁的性能消耗''比较大'，
通常'我们会对'于'一些竞争''不是那么激烈'，
但是其'又需要保证'我们'并发的顺序执行''使用乐观锁进行处理'，
我们'可以对'我们的'表''加一个版本号字段'，那么我们'查询出来一个版本号'之'后'，
'update或者delete的时候'需'要依赖我们查询出来的版本号'，
'判断当前数据库'和'查询出来的版本号'是否相等，'如果相等'那么'就可以执行'，
如果'不等'那么'就不能执行'。这样的一个'策略很像'我们的'CAS'(Compare And Swap),
比较并交换是一个原子操作。这样我们就能避免加select * for update行锁的开销。

4. 'ZooKeeper'
'ZooKeeper'也'是'我们'常见的''实现分布式锁方法'，
相比于数据库'如果没了解过ZooKeeper''可能上手比较难一些'。
'ZooKeeper''是以Paxos算法为基础的''分布式应用程序协调服务'。
'Zk的数据节点'和'文件目录类似'，所以'我们可以''用此特性''实现分布式锁'。
我们'以某个资源为目录'，然后'这个目录下面的节点'就'是我们需要获取锁的客户端'，
'未获取到锁的''客户端注册''需要注册Watcher到上''一个客户端'，可以用下图表示。

'/lock是'我们'用于加锁的目录','/resource_name是'我们'锁定的资源'，
其下面的'节点'按'照我们加锁的顺序''排列'。

4.1'Curator'
'Curator''封装了Zookeeper底层的Api'，使我们'更加容易方便'的'对Zookeeper进行操作'，
并且'它封装了分布式锁的功能'，这样我们'就不需要再自己实现了'。

'Curator''实现了可重入锁'(InterProcessMutex),
也'实现了不可重入锁'(InterProcessSemaphoreMutex)。
在'可重入锁'中'还实现了读写锁'。

4.2'InterProcessMutex'
'InterProcessMutex''是Curator实现的''可重入锁'，
我们'可以''通过下面的一段代码''实现我们的可重入锁':


我们利'用acuire''进行加锁'，'release''进行解锁'。

加锁的流程具体如下:

首先进行'可重入的判定':'这里的可重入锁''记录在ConcurrentMap'
'threadData''这个Map里面'，'如果threadData.get(currentThread)''是有值的''那么就证明''是可重入锁'，
然后'记录就会加1'。我们'之前的Mysql'其实'也可以通过这种方法''去优化'，
'可以不需要count字段的值'，'将这个维护在本地''可以提高性能'。
'然后''在我们的资源目录下''创建一个节点':比如'这里创建一个/0000000002这个节点'，
'这个节点'需'要设置为EPHEMERAL_SEQUENTIAL'也'就是临时节点并且有序'。

'获取当前目录下''所有子节点'，'判断自己的节点''是否位于子节点第一个'。
'如果是第一个'，'则获取到锁'，'那么可以返回'。
'如果不是第一个'，'则证明前面已经有人获取到锁了'，'那么需要获取自己节点的''前一个节点'。
'/0000000002的''前一个节点是''/0000000001'，我们'获取到这个节点之后'，
'再上面注册Watcher'(这里的watcher其实调用的是object.notifyAll(),'用来解除阻塞')。
'object.wait'(timeout)'或object.wait'():'进行阻塞等待这里''和我们第5步的watcher相对应'。

'解锁的具体流程':
'首先''进行可重入锁的判定':'如果有可重入锁''只需要次数减1即可'，
'减1之后''加锁次数为0的话继续下面步骤'，'不为0直接返回'。
'删除当前节点'。
'删除threadDataMap里面的可重入锁的数据'。

'4.3读写锁'
'Curator提供了读写锁'，'其实现类是''InterProcessReadWriteLock'，
'这里的每个节点''都会加上前缀'：

private static final String READ_LOCK_NAME  = "__READ__";
private static final String WRITE_LOCK_NAME = "__WRIT__";
'根据不同的前缀''区分是读锁还是写锁'，'对于读锁'，'如果发现前面有写锁'，
那么'需要将watcher注册到''和自己最近的写锁'。'写锁的逻辑'
'和我们之前4.2分析的依然保持不变'。

'4.4锁超时'
'Zookeeper''不需要配置锁超时'，'由于我们设置节点''是临时节点'，
我们的'每个机器维护着一个ZK的session'，'通过这个session'，'ZK可以判断机器是否宕机'。
'如果我们的机器挂掉的话'，那么'这个临时节点''对应的就会被删除'，
所以我们'不需要关心锁超时'。

4.5 ZK小结
优点:'ZK可以不需要关心锁超时'时间，实现起来'有现成的第三方包'，比较方便，
并且'支持读写锁'，'ZK获取锁会按照加锁的顺序'，所以其'是公平锁'。
'对于高可用利用ZK集群''进行保证'。

缺点:'ZK需要额外维护'，'增加维护成本'，'性能和Mysql相差不大'，依然比较差。
并且需要开发人员了解ZK是什么。

5.'Redis'
'大家在网上搜索分布式锁'，恐怕'最多的实现''就是Redis'了，Redis因为其性能好，
实现起来简单所以让很多人都对其十分青睐。

5.1'Redis分布式锁简单实现'
熟悉Redis的同学那么肯定对'setNx(set if not exist)'方法不陌生，
如果'不存在则更新'，其可以很好的用来实现我们的分布式锁。
对于某个资源加锁我们只需要

'setNx resourceName value'
这里有个问题，'加锁了之后''如果机器宕机''那么这个锁就不会得到释放''所以会加入过期时间'，
'加入过期时间''需要和setNx''同一个原子操作'，
'在Redis2.8之前'我们'需要使用Lua脚本''达到我们的目的'，
'但是redis2.8之后''redis支持nx和ex操作''是同一原子操作'。
'set resourceName value ex 5 nx'

5.2'Redission'
Javaer都知道Jedis，Jedis是Redis的Java实现的客户端，
其API提供了比较全面的Redis命令的支持。'Redission'也'是Redis的客户端'，
相比于Jedis功能简单。Jedis简单使用阻塞的I/O和redis交互，
'Redission通过Netty支持非阻塞I/O'。
Jedis最新版本2.9.0是2016年的快3年了没有更新，
而Redission最新版本是2018.10月更新。

'Redission''封装了锁的实现'，其'继承了java.util.concurrent.locks.Lock的接口'，
让我们'像操作我们的本地Lock一样''去操作Redission的Lock'，
下面'介绍一下其如何实现分布式锁'。

'Redission''不仅提供了Java自带的一些方法'(lock,tryLock)，
'还提供了异步加锁'，'对于异步编程更加方便'。
'由于内部源码较多'，就不贴源码了，这里'用文字叙述来分析他是如何加锁的'，
这里'分析一下tryLock方法':

'尝试加锁':'首先会尝试进行加锁'，由于'需要兼容老版本的Redis'，
所以'不能直接使用ex nx原子操作的API'，那么就'只能使用lua脚本'，
相关的lua脚本如下：

可以看见'他并没有使用我们的sexNx来进行操作'，'而是使用的hash结构'，
我们的'每一个需要锁定的资源''都可以看做是一个HashMap'，
'锁定资源的节点信息是Key','锁定次数是value'。
'通过这种方式'可以'很好的实现可重入的效果'，'只需要对value进行加1操作'，
'就能进行可重入锁'。当然这里也可以用之前我们说的本地计数进行优化。

如果'尝试加锁失败'，'判断是否超时'，如果'超时则返回false'。

如果'加锁失败之后'，'没有超时'，
那么'需要在名字为''redisson_lock__channel+lockName''的channel上进行订阅'，
'用于订阅解锁消息'，'然后一直阻塞''直到超时'，'或者有解锁消息'。

'重试步骤1，2，3'，'直到最后获取到锁'，'或者某一步''获取锁超时'。

'对于我们的unlock方法''比较简单''也是通过lua脚本进行解锁'，
'如果是可重入锁'，'只是减1'。'如果是非加锁线程解锁'，'那么解锁失败'。


'Redission''还有公平锁的实现'，
'对于公平锁'其'利用了list结构''和hashset结构'分别'用来保存'我们'排队的节点'，
'和'我们'节点的过期时间'，用这'两个数据结构''帮助我们实现公平锁'，
这里就不展开介绍了，有兴趣可以参考源码。

5.3'RedLock'
'我们想象一个这样的场景''当机器A申请到一把锁之后'，'如果Redis主宕机了'，
'这个时候'从机'并没有同步到这一把锁'，那么'机器B再次申请的时候''就会再次申请到这把锁'，
'为了解决这个问题''Redis作者''提出了RedLock红锁的算法',
'在Redission中''也对RedLock进行了实现'。

'通过上面的代码'，我们'需要实现多个Redis集群'，然后'进行红锁的加锁'，
'解锁'。具体的步骤如下:

'首先生成多个Redis集群的Rlock'，'并将其构造成RedLock'。

'依次循环''对三个集群''进行加锁'，'加锁的过程''和5.2里面一致'。

如果'循环加锁的过程'中'加锁失败'，那么'需要判断加锁失败的次数''是否超出了最大值'，
'这里的最大值''是根据集群的个数'，'比如三个''那么只允许失败一个'，
'五个的话''只允许失败两个'，'要保证多数成功'。

'加锁的过程'中'需要判断是否加锁超时'，'有可能我们设置加锁''只能用3ms'，
'第一个集群''加锁已经消耗了3ms了'。那么'也算加锁失败'。

3，'4步里面加锁失败的话'，那么'就会进行解锁操作'，
'解锁会对所有的集群''在请求一次解锁'。

可以看见'RedLock基本原理'是'利用多个Redis集群'，'用多数的集群加锁成功'，
'减少Redis某个集群出故障'，'造成分布式锁出现问题的概率'。

5.4 Redis小结
优点:'对于Redis实现简单'，'性能对比ZK和Mysql较好'。'如果不需要特别复杂的要求'，
那么'自己就可以利用setNx进行实现'，
'如果自己需要复杂的需求'的话'那么可以利用或者借鉴Redission'。
'对于一些要求比较严格的场景来说'的话'可以使用RedLock'。

'缺点:需要维护Redis集群'，'如果要实现RedLock'那么'需要维护更多的集群'。

6.'分布式锁的安全问题'
上面我们介绍过红锁，但是'Martin Kleppmann认为'其'依然不安全'。
有关于'Martin反驳的几点'，我认为'其实不仅仅局限于RedLock',
前面说的'算法基本都有这个问题'，下面我们来'讨论一下这些问题:'

'长时间的GC pause':熟悉Java的同学肯定对GC不陌生，
'在GC的时候会发生STW'(stop-the-world),例如CMS垃圾回收器，
他'会有两个阶段进行STW防止引用继续进行变化'。
'那么有可能''''(引用至Martin反驳Redlock的文章)中'这个情况'：


client1获取了锁并且设置了锁的超时时间，但是client1之后出现了STW，
这个STW时间比较长，导致分布式锁进行了释放，client2获取到了锁，
这个时候client1恢复了锁，那么就会出现client1，2同时获取到锁，
这个时候分布式锁不安全问题就出现了。这个其实不仅仅局限于RedLock,
对于我们的ZK,Mysql一样的有同样的问题。

时钟发生跳跃:对于Redis服务器如果其时间发生了向跳跃，
那么肯定会影响我们锁的过期时间，那么我们的锁过期时间就不是我们预期的了，
也会出现client1和client2获取到同一把锁，那么也会出现不安全，
这个对于Mysql也会出现。但是ZK由于没有设置过期时间，
那么发生跳跃也不会受影响。

长时间的网络I/O:这个问题和我们的GC的STW很像，
也就是我们这个获取了锁之后我们进行网络调用，
其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题，
这个Mysql也会有，ZK也不会出现这个问题。

对于这三个问题，在网上包括Redis作者在内发起了很多讨论。

6.1 GC的STW
对于这个问题可以看见基本所有的都会出现问题，Martin给出了一个解法，
对于ZK这种他会生成一个自增的序列，那么我们真正进行对资源操作的时候，
需要判断当前序列是否是最新，有点类似于我们乐观锁。
当然这个解法Redis作者进行了反驳，
你既然都能生成一个自增的序列了那么你完全不需要加锁了，
也就是可以按照类似于Mysql乐观锁的解法去做。

我自己认为这种解法增加了复杂性，
当我们对资源操作的时候需要增加判断序列号是否是最新，
无论用什么判断方法都会增加复杂度，后面会介绍谷歌的Chubby提出了一个更好的方案。

6.2 时钟发生跳跃
Martin觉得RedLock不安全很大的原因也是因为时钟的跳跃，
因为锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。
Redis作者也给出了解答:对于时间跳跃分为人为调整和NTP自动调整。

人为调整:人为调整影响的那么完全可以人为不调整，这个是处于可控的。

NTP自动调整:这个可以通过一定的优化，把跳跃时间控制的可控范围内，
虽然会跳跃，但是是完全可以接受的。

6.3长时间的网络I/O
这一块不是他们讨论的重点，我自己觉得，
对于这个问题的优化可以控制网络调用的超时时间，
把所有网络调用的超时时间相加，那么我们锁过期时间其实应该大于这个时间，
当然也可以通过优化网络调用比如串行改成并行，异步化等。
可以参考我的两个文章:
并行化-你的高并发大杀器，异步化-你的高并发大杀器

7.Chubby的一些优化
大家搜索ZK的时候，会发现他们都写了ZK是Chubby的开源实现，
Chubby内部工作原理和ZK类似。但是Chubby的定位是分布式锁和ZK有点不同。
Chubby也是使用上面自增序列的方案用来解决分布式不安全的问题，
但是他提供了多种校验方法:

CheckSequencer()：调用Chubby的API检查此时这个序列号是否有效。

访问资源服务器检查，判断当前资源服务器最新的序列号和我们的序列号的大小。

lock-delay:为了防止我们校验的逻辑入侵我们的资源服务器，
其提供了一种方法当客户端失联的时候，并不会立即释放锁，
而是在一定的时间内(默认1min)阻止其他客户端拿去这个锁，
那么也就是给予了一定的buffer等待STW恢复，
而我们的GC的STW时间如果比1min还长那么你应该检查你的程序，而不是怀疑你的分布式锁了。

8.小结
本文主要讲了多种分布式锁的实现方法，以及他们的一些优缺点。
最后也说了一下有关于分布式锁的安全的问题，
对于不同的业务需要的安全程度完全不同，我们需要根据自己的业务场景，
通过不同的维度分析，选取最适合自己的方案。
