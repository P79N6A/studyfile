1.延迟任务 场景，特点
e：外卖
  12306 
  【他们和定时任务有差别】
   
2.数据库轮询
  一个线程扫描数据库定时任务，通过时间更新
  ordr:   id，status，createtime
  
  1分钟有点大 会影响数据库性能
  【局限，只能应用到数据量不大的表】  
  不可取  ×
  
  jdk延迟队列
  做一件事情--指定时间之后，处理另外一件事情
  jdk延迟队列 DelayQueue是无界延迟阻塞队列，放入元素要实现Delayed接口
  
  生产者生产一个任务----》处理任务通过
  
  Delayed（10s）
  当前时间戳+10S=超时时间戳（poll/take拿出Delayed）获取定时任务

  故障处理/持久化
  
3.redis zset   //不用redis超时，不安全【不太稳定，有可能不执行】
  时间戳和单号设置为  score和member
  拿最小时间戳和当前时间戳对比-->超时就过期
  
  基于一致性的问题，我要先做业务
  但是分布式条件下，需要弄分布式锁来，可能会有并发问题，搞定不然会出现问题
  
  【
  最终选择先删数据，再业务处理，再保证业务处理成功！
  //如果失败！！！   通过子系统最降级做重试，或者3次循环：同过mq挂起来，如果失败了，重新处理
  不会有问题{redis单线程单进程，保证只有一个人真正删除成功}
  】
  
4.RabbitMQ TTL（过期时间）+DLX（死信交换器）
  设置消息过期时间 过期后投递到死信交换器。再投到死信队列中，重新消费
  
  rabbitMQ 先把数据发给交换器，交换器透过路由绑定队列；消费者可以主动和被动拿数据
  rabbitMQ 有拒绝reject  事务  ack（手动确认这个id，我处理过了）机制，判断业务是否成功
  ack是手动确认机制 从mq出来的数据，会及时删除吗?不会，确认后才会【自动，只有拿到数据就删.手动通过ack()反馈成功，再删除】

  【
   如何保证数据不丢失？ 
   如何保证集群高可用？ nginx
   增加rabbitmq维护，占用宽带
   】
		  
		  

