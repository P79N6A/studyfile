课前必读（不看会错过一个亿）
大家平时可能'关心的问题汇总'：
说明：'本教程所用图示'暂'统一用'《FFmpeg'音视频核心技术精讲与实战'》'课程做图示'

一、'课程源码'，'教辅材料怎么下载？'
'Step1':'进入课程页'，'点击'进入课程'按钮'
'Step2':'选择下载标签'，'进入下载'区，'点击'对应'资料按钮'，
'下载对应资料'（'源码用Git管理'，'账号，密码'为'你的课网账号密码'）

二、'课程QQ交流群怎么加入？'
'点击进入课程页'，网页'右侧评价区下方'就'可以看到课程QQ群'以'及对应的唯一验证码图片'描述
例如

三、'学习遇到问题后，怎么办？'
Step1 '调整学习心态'，学习中遇到问题不要怕，也很正常，问题是磨刀石，
'解决问题的过程'也'是学习和提升的过程'，抓住每一次自我解决问题机会，是高效学习关键。
Step2 '先尝试自己分析和解决问题'，也要'用好百度，谷歌，课程QQ交流群'。
Step3.如果自己'努力后'，'依然无法解决问题'，可以整理问题，'发布到课程问答区'，
让老师回答，问答区使用方式如下：

四、'去哪阅读老师写过的''文章手记'或老师讲的'其他课程'？
Step1 '找到讲师头像'，点击讲师头像，'进入讲师个人页'，老师讲过的课，
写过的手记文章一目了然

五、'是否可以开发票'，'课程有效时长多久'，附加服务，视频播放问题，账号异常等问题，
可阅读以下文章
文章地址：https://www.imooc.com/help

六、'如对本课程有优化建议或者有新课需求怎么反馈？'
反馈通道-教学管理QQ：3384168365
任务


JMM（java内存模型【'规定一个线程''如何，何时''能够看到''其他线程共享的值'，
'和''在必须时'，'如何访问共享变量'】）

同步操作和规则
8种操作：
lock（锁定）作用主内存   （锁定）
unlock（解锁）作用主内存 （释放）
read（读取）作用主内存 

load（载入）作用工作内存
use（使用）作用工作内存  
assign（赋值）作用工作内存
store（存储）作用工作内存

write（写入）作用主内存

规则：
'不允许''read/load，store/write''单一出现'
'不允许''线程丢弃最近得assign操作'（'工作内存''变量变化后''必须同步给''主内存'）
'不允许''一个线程没发生assign操作'，'就从工作内存''同步到主内存'
'新变量''只能从主内存''诞生'
'一变量''同时只能被''一个线程lock'，'lock可被同一线程''执行多次'(重入锁)
'一变量''执行lock'，'会清空在''主内存得值'，'只有经过read/load'，'才能在''工作内存中使用'
'未被lock得变量''不允许unlock'，'也不允许其他线程''对已被lock得变量unlock'
'对一个变量执行unlock'，'必须先把变量''同步到主内存'

线程安全：
'并发环境下'，'得到期望值'，'就是线程安全'

并发工具
'postman'
'apach bench'
'jemeter'

并发模拟'代码' 'CountDownLatch'，'Semaphore'
'ExecutorService executorService = Executors.newCachedThreadPool()';

//线程安全性-原子性-atomic

多个线程访问某个类，'不管'运行环境采用'何种调度方式'，
不管线程如何交替执行并且再主代码中'不需要任何额外的同步或协同'，
'都表现正确行为'，就是线程安全

原子性：'提供互斥访问'，只有一个线程能对它做操作
可见性：'一个线程对主内存的修改'，可以'及时被其他线程观察到'
有序性：一个线程观察其他线程指令顺序，'由于重排序存在'，观察'结果一般杂乱无序'

'Atomic'
'通过CAS完成原子性'

AtomicInteger，AtomicXXX
AtomicLog,AtomicAdder
AtomicReference,AtomicReferenceFieldUpdater
AtomicStampReference:'CAS的ABA问题'

synchronized：'依赖JVM'
修饰'代码块': 	'当前对象'  
修饰'方法'：	'当前对象'
修饰'静态方法'：'所有对象'
修饰'类'：		'所有对象'

Lock：依赖
'synchronized'：不可中断锁，适合竞争不激烈  '竞争激烈性能大降'
'Lock'：'可中断锁'，多样化同步，'竞争激烈时能维持常态'
'Atomic'：'竞争激烈维持常态'，比Lock'性能好'；'只能同步一个值'

可见性
导致不可见的原因
1'线程交叉执行'
2'重排序''结合''线程交叉执行'
3'共享变量更新后的值'，'没有在工作内存''和主内存之间''及时更新'

可见性-synchronized
1'线程解锁前'，必'须把共享变量最新的值'，'刷新到主内存'中
2'线程加锁时'，'将清空工作内存中''共享变量的值'，
从而'使用共享变量时'需'要从主内存'中重新'读取最新的值'（注意'加锁和解锁是同一把锁'）

可见性-volatile
通过'内存屏障'和'禁止重排序'优化实现
1'对volatile变量写操作'时，会'在写后加入store屏障'，'将本地内存中'
的'共享变量刷新到主内存'
2'对volatile变量读操作'时，会'在读后加入load屏障'，'将主内存'中
的'共享变量读取到主内存'

'volatile使用场景'
1,'对变量写不依赖当前值','适合作为状态标识'【如标识是否已经'初始化'】
2,'检查两次'


有序性
JVM'允许编译器和处理器''对指令'进行'重排序'，但是'重排'过程'不影响单线程的执行'
却'会影响多线程并发执行的正确性'

volatile，synchronized，Lock

jvm具有一些先天有序

'happens-befor原则'【单线程'看起来执行的顺序''是代码顺序'】
'1程序次序原则'：'一个程序'，按'照代码顺序'，
书'写在前面的操作'，'先行发生'于书写在后面的操作

'2锁定规则'：'一个unlock操作先行发生'于后面'对同一个锁的lock操作'

'3volatile变量规则'：'对一个变量的写操作'
'先行发生'于后面'对这个变量的读操作'

'4传递规则'

5线程对象'start先发生于该线程每一个动作'

6对线程'interrupt方法''的调用''先发生于被中断线程'的'代码检测到中断事件的发生'

7'所有操作'都'先发生于线程的终止检测'，我们可以通过Thread.join()方法结束
Thread.isAlive()的返回值手段检测到线程已经终止执行

8'对象终结规则'，一个'对象初始化'完成'先行发生于他的finalize方法的开始'





















