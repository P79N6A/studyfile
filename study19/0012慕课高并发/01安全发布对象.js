'发布对象'：'使一个对象'能够'被''当前范围之外的代码'所'使用'
'对象溢出'：一种'错误的发布'，当'一个对象'还'没'又'构造完成'时，
'就使它被''其他线程所见'

'如果不正确'，'两个错误'
1'发布线程以外的任何线程'都'可以看到''被发布'对象'的过期'的'值'
2'线程看到的被发布'对象'的引用''是最新的'，'被发布'对象'的状态'确'是过期的'
'如果对象'是'可变'对象，一定'要安全发布才行'


'安全发布'对象的'四种方法'
1在'静态初始化函数中''初始化'一个'对象引用'
2将'对象的引用''保存到volatile类型域''或者AtomicReference对象中'
3将'对象的引用''保存到某个正确构造对象的''final类型域中'
4将'对象的引用''保存到'一个由'锁保护的域中'


懒汉模式//线程不安全
* 单例实例在'第一次使用时'进行'创建'

饿汉模式//可能引起性能问题{实例化时没有做很多事条件下能使用}
* 单例实例在'类装载时'进行'创建'

懒汉模式//性能问题
* 单例实例在'第一次使用时进行创建'用synchronized修饰

懒汉模式 -》 双重同步锁单例模式 //线程不安全
* 单例实例在第一次使用时进行创建
 1、memory = allocate() '分配对象'的'内存空间'
 2、ctorInstance() '初始化对象'
 3、instance = memory '设置instance''指向刚分配的内存'
 JVM和cpu优化，'发生'了'指令重排'
 1、memory = allocate() '分配对象'的'内存空间'
 3、instance = memory '设置instance''指向刚分配的内存'
 2、ctorInstance() '初始化对象'

懒汉模式 -》 双重同步锁单例模式 用volatile限制指令重排//线程安全
 * 单例实例在第一次使用时进行创建
  1、memory = allocate() 分配对象的内存空间
  2、ctorInstance() 初始化对象
  3、instance = memory 设置instance指向刚分配的内存
  单例对象 volatile + 双重检测机制 -> 禁止指令重排
 private volatile static SingletonExample5 instance = null;

 饿汉模式
 * 单例实例在类装载时进行创建
 
 枚举模式
 能保证线程安全，能在使用时创建对象，所以推荐使用
 
 
 
 
 
 
 