1.'非分片字段''查询'
'Mycat中的路由'结果是'通过分片字段'和'分片方法'来'确定'的。
例如下图中的一个'Mycat分库方案'：
	'根据 tt_waybill' 表的 'id' 字段来'进行分片'
	'分片方法'为 id 值取 3 的模，根据模值确定在DB1，DB2，DB3中的某个分片

select * from tt_waybill where waybill_no = '88611'
				  | 
				  |    id     waybill_no
					  12330		88661
		id%3==0  DB1  12333		88662
					  
					  12331		88663
mycat   id%3==1  DB2  12334		88664

					  12332		88665
		id%3==2  DB3  12335		88666
		
如果'查询条件'中有 'id' 字段的情况还好，查询将会'落到某个具体的分片'。例如：
	mysql > select * from tt_waybill where id = 12330;
此时'Mycat'会'计算路由结果'
	12330 % 3 = 0 –> DB1
并'将该请求路由''到DB1上去执行'。 

如果'查询条件'中'没有分片字段'条件，例如：
	mysql > select * from tt_waybill where waybill_no =88661;
此时'Mycat无法计算路由'，便发送'到所有节点上执行'：
DB1 –> select * from tt_waybill where waybill_no =88661; 
DB2 –> select * from tt_waybill where waybill_no =88661; 
DB3 –> select * from tt_waybill where waybill_no =88661; 

'如果该分片字段''选择度高'，也'是业务常用'的'查询维度'，一般'只有一个'或'极少数个'DB节点命中
（返回结果集）。
示例中只有3个DB节点，而'实际应用中'的DB'节点数远超过这个'，假如'有50个'，
那么'前端的一个查询'，'落到MySQL数据库上'则'变成50个查询'，'会极大消耗Mycat'和'MySQL数据库资源'。

如果'设计使用Mycat时'有'非分片字段查询'，请'考虑放弃'！

2.'分页排序'
'先看一下Mycat'是'如何处理分页'操作的，'假如有如下'Mycat'分库方案'： 
一张表有'30份数据''分布在3个分片DB上'，具体数据分布如下
'DB1：[0,1,2,3,4,10,11,12,13,14]' 
'DB2：[5,6,7,8,9,16,17,18,19]' 
'DB3：[20,21,22,23,24,25,26,27,28,29]'
（'这个示例'的场景中'没有查询条件'，所以'都是全分片查询'，也就'没有'假定该表的'分片字段'和'分片方法'）
					| 
				id%3==0  DB1  【0,1,2,3,4,10,11,12,13,14】
	 【0,1】					  
mycat【5,6】    id%3==1  DB2  【5,6,7,8,9,16,17,18,19】
	 【20,21】				 
		  	    id%3==2  DB3  【20,21,22,23,24,25,26,27,28,29】
当应用'执行如下分页查询'时
mysql>select * from table limit 2;
DB1: [0,1] 
DB2: [5,6] 
DB3: [20,21]
但'Mycat'向应用'返回的结果集'取决于'哪个DB节点''最先''返回结果给Mycat'。
如果'Mycat最先收到DB1节点'的'结果集'，
那么Mycat返回给应用端的结果集'为 [0,1]'，
如果'Mycat最先收到DB2节点'的'结果集'，
那么返回给应用端的结果集'为 [5,6]'。
也就是说，'相同情况'下，'同一个SQL'，
在Mycat上执行时会有'不同的返回结果'。

在'Mycat中执行分页操作'时必须'显示加上排序条件''才能保证'结果的'正确性'，
下面看一下'Mycat对排序分页'的'处理逻辑'。 
假如在前面的'分页查询中''加上了排序条件'（假如表数据的列名为id）

mysql>select * from table order by id limit 2;
		取最小【0,1】
			|		id%3==0  DB1  【0,1,2,3,4,10,11,12,13,14】
		 【0,1】					  
mycat	 【5,6】    	id%3==1  DB2  【5,6,7,8,9,16,17,18,19】
		【20,21】				 
	  	    		id%3==2  DB3  【20,21,22,23,24,25,26,27,28,29】
	  	    		
在有'排序'呢'条件'的'情况下'，Mycat'接收'到'各个DB节点'的返回'结果后'，'对'其进行'最小堆运算'，
计算出'所有结果集中''最小的两条记录' [0,1] 返回给应用。

但是，'当排序分页'中'有 偏移量 （offset）时'，处理'逻辑又有不同'。假如应用的查询SQL如下：
mysql>select * from table order by id limit 5,2;
'【错误处理】'
		取最小【10,11】
			|		id%3==0  DB1  【0,1,2,3,4,10,11,12,13,14】
		 【10,11】					  
mycat	 【16,17】  id%3==1  DB2  【5,6,7,8,9,16,17,18,19】
		 【25,26】				 
  					id%3==2  DB3  【20,21,22,23,24,25,26,27,28,29】
  					
'Mycat将'各个DB节点'返回的数据' [10,11], [16,17], [20,21] 经过'最小堆计算'后返回给应用的
'结果集'是 '[10,11]'。可是，对于应用而言，该表的'所有数据'明明是 0-29 这30个数据的'集合'，
limit 5,2 操作返回的'结果集应该是 [5,6]'，如果'返回 [10,11]' 则是'错误的处理逻辑'。
'【正确处理】'                【改写sql  limit 0,5+2;】
		取最小【0,1,2,3,4,10,11】
					|			id%3==0  DB1  【0,1,2,3,4,10,11,12,13,14】
		 【0,1,2,3,4,10,11】					  
mycat	 【5,6,7,8,9,16,17】  	id%3==1  DB2  【5,6,7,8,9,16,17,18,19】
		 【20,21,22,23,24,25,26】				 
								id%3==2  DB3  【20,21,22,23,24,25,26,27,28,29】
'Mycat'在'下发有 limit m,n' 的SQL语句时'会对其进行改写'，改'写成 limit 0, m+n' 来'保证'查询'结果的逻辑正确性'。
所以，'Mycat发送到后端DB'上的'SQL语句是'
mysql>select * from table order by id limit 0,7;

各个DB返回给Mycat的结果集是
DB1: [0,1,2,3,4,10,11] 
DB2: [5,6,7,8,9,16,17] 
DB3: [20,21,22,23,24,25,26]
经过'最小堆计算后得到'最小序列 '[0,1,2,3,4,5,6]' ，然后'返回偏移量为5的两个结果为 [5,6]' 。

'虽然'Mycat'返回了正确的结果'，但是'仔细推敲发现'这类操作的'处理逻辑'是'及其消耗（浪费）资源'的。
应用需要的结果集为2条，Mycat中需要处理的结果数为21条。也就是说，
'对于有 t 个DB节点'的'全分片 limit m, n 操作'，'Mycat需要处理的数据量为 (m+n)*t 个'。
比如'实际应用中有50个DB节点'，要执行'limit 1000,10操作'，则'Mycat处理的数据量为 50500 条'，
'返回结果集为10'，当'偏移量更大时'，'内存和CPU资源的消耗则是数十倍增加'。
'如果设计使用Mycat'时'有分页排序'，请'考虑放弃！'

3.任意表JOIN
先看一下在'单库中JOIN'中的场景。假设'在某单库'中'有 player 和 team 两张表'，
'player 表中的 team_id 字段'与 'team 表中的 id' 字段'相关联'。操作场景如下图：
												player表				team表		
						 <——————————————————no  p_name team_id     id  t_name
				p_name t_name				3	 Wade    1          2  Cavalier 
				 Wade	Heat				23   James   2          1   Heat


mysql>select p_name,t_name from player p, team t where p.no = 3 and p.team_id = t.id;
p_name	t_name
Wade	Heat

如果将这两个表的数据分库后，'相关联的数据'可能'分布在不同的DB节点上'，如下图：
这个'SQL在各个单独的分片DB中'都'查不出结果'，也就是说'Mycat不能查询出正确的结果集'。
设计使用Mycat时如果要'进行表JOIN操作'，要'确保两个表的关联字段'具有'相同的数据分布'，否则'请考虑放弃'！


4.分布式事务
'Mycat'并'没有根据二阶段提交协议实现 XA事务'，而是'只保证 prepare 阶段数据一致性'的 弱XA事务 ，实现过程如下：
'应用开启事务后'Mycat'标识该连接为非自动提交'，比如'前端执行'
mysql>begin;
'Mycat不会立即把命令发送到DB节点上'，'等后续下发SQL时'，
'Mycat'从连接池'获取非自动提交的连接''去执行'。

'Mycat会等待各个节点的返回结果'，如果'都执行成功'，Mycat'给该连接标识为 Prepare Ready 状态'，
如果'有一个节点执行失败'，则'标识为 Rollback 状态'。

'执行完成后'Mycat'等待前端发送 commit 或 rollback 命令'。'发送 commit 命令时'，
'Mycat检测当前连接是否为 Prepare Ready 状态'，'若是'，则'将 commit 命令发送到各个DB节点'。

但是，'这一阶段是无法保证一致性的'，如果'一个DB节点在 commit 时故障'，而'其他DB节点 commit 成功'，
'Mycat会一直等待故障DB节点返回结果'。Mycat'只有收到所有DB节点的成功执行结果''才会向前端返回 执行成功' 的包，
此时'Mycat只能一直 waiting 直至TIMEOUT'，'导致事务一致性被破坏'。

设计使用Mycat时如果'有分布式事务'，得先看'是否得保证事务得强一致性'，否则请考虑放弃！




