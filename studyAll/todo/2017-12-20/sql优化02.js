'大数据量''高并发'访问的'数据库优化方法'(一) (2013-06-24 17:16:21)转载▼
一、数据库结构的设计

    如果不能设计一个合理的数据库模型，不仅会增加客户端和服务器段程序的编程和维护的难度，而且将会影响系统实际运行的性能。
所以，在一个系统开始实施之前，完备的数据库模型的设计是必须的。

    在一个系统分析、设计阶段，因为数据量较小，负荷较低。我们往往只注意到功能的实现，而很难注意到性能的薄弱之处，
等到系统投入实际运行一段时间后，才发现系统的性能在降低，这时再来考虑提高系统性能则要花费更多的人力物力，
而整个系统也不可避免的形成了一个打补丁工程。

    所以在考虑整个系统的流程的时候，我们必须要考虑，在'高并发大数据量'的访问情况下，我们的系统'会不会出现极端的情况'。
（例如：对外统计系统在7月16日出现的数据异常的情况，并发大数据量的的访问造成，数据库的响应时间不能跟上数据刷新的速度造成。
具体情况是：在'日期临界'时（00：00：00），'判断'数据库中'是否有当前日期的记录'，没有则插入一条当前日期的记录。
在'低并发'访问的情况下，'不会发生问题'，但是当日期临界时的'访问量相当大的时候'，在做这一判断的时候，会'出现多次条件成立'，
则'数据库'里'会被插入多条当前日期的记录'，从而'造成数据错误'。），数据库的模型确定下来之后，
我们'有必要做一个系统内数据流向图'，分析可能出现的瓶颈。

    '为了保证'数据库的'一致性和完整性'，在逻辑'设计的时候'往往会'设计过多的表间关联'，尽可能的'降低数据的冗余'。
（例如用户表的地区，我们可以'把地区另外存放到一个地区表中'）如果数据'冗余低'，数据的'完整性容易得到保证'，'提高了数据吞吐速度'，
'保证'了数据的'完整性'，清楚地表达数据元素之间的关系。而对于多表之间的关联查询（尤其是大数据表）时，其性能将会降低，
同时也提高了客户端程序的编程难度，因此，物理设计需折衷考虑，根据业务规则，确定对关联表的数据量大小、数据项的访问频度，
对此类数据表频繁的关联查询应适当提高数据冗余设计但增加了表间连接查询的操作，也使得程序的变得复杂，为了提高系统的响应时间，
合理的数据冗余也是必要的。设计人员在设计阶段应根据系统操作的类型、频度加以均衡考虑。
另外，最好不要用自增属性字段作为主键与子表关联。不便于系统的迁移和数据恢复。对外统计系统映射关系丢失（******************）。

    '原来的表格'必须可以'通过由它分离出去的表格重新构建'。使用这个规定的'好处是'，你可以'确保'不会'在分离的表格中引入多余的列'，
所有你创建的表格结构都与它们的实际需要一样大。应用这条规定是一个好习惯，'不过除非你要处理一个非常大型的数据'，否则'你将不需要用到它'。
（例如一个通行证系统，我可以将USERID，USERNAME，USERPASSWORD，单独出来作个表，再把USERID作为其他表的外键）

表的设计具体注意的问题：

    1、数据行的'长度不要超过8020字节'，如果'超过这个长度'的话在物理页中'这条数据'会'占用两行从而造成存储碎片'，降低查询效率。
    2、'能够用数字类型的字段'尽量'选择数字类型'而不用字符串类型的（'电话号码'），这会'降低查询和连接的性能'，并会增加存储开销。
这是因为'引擎在处理查询和连接会逐个比较字符串中''每一个字符'，而'对于数字型'而言'只需要比较一次'就够了。

    3、对于'不可变字符类型char'和'可变字符类型varchar' 都是8000字节,'char查询快'，但是'耗存储空间'，'varchar查询相对慢一些但是节省存储空间'。
在'设计字段的时候可以灵活选择'，例如'用户名、密码等长度变化不大的字段'可以'选择CHAR'，对于'评论等长度变化大的字段'可以'选择VARCHAR'。

    4、'字段的长度在最大限度的满足可能的需要的前提下'，应该'尽可能的设得短一些'，这样可以'提高查询的效率'，
而且在'建立索引的时候也可以减少资源的消耗'。


二、'查询的优化'
保证'在实现功能的基础上'，尽量'减少对数据库的访问次数'；通过'搜索参数'，尽量'减少对表的访问行数','最小化结果集'，从而减轻网络负担；
'能够分开的操作'尽量'分开处理'，'提高每次的响应速度'；在'数据窗口使用SQL时'，尽量'把使用的索引放在选择的首列'；
'算法的结构尽量简单'；在查询时，'不要过多地使用通配符如SELECT * FROM T1语句'，要用到几列就选择几列如：SELECT COL1,COL2 FROM T1；
在可能的情况下'尽量限制尽量结果集行数'如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为'某些情况下''用户是不需要那么多的数据的'。   
在'没有建索引的情况下'，'数据库查找某一条数据'，就'必须进行全表扫描'了，对所有数据进行一次遍历，查找出符合条件的记录。
在数据量比较小的情况下，也许看不出明显的差别，但是当'数据量大的情况'下，这种情况就是'极为糟糕'的了。
SQL语句在SQL SERVER中是如何执行的，他们担心自己所写的SQL语句会被SQL SERVER误解。比如： 
select * from table1 where name='zhangsan' and tID > 10000; 
和执行:
select * from table1 where tID > 10000 and name='zhangsan';
一些人不知道'以上两条语句的执行效率是否一样'，因为如果简单的'从语句先后上看'，这两个语句的确'是不一样'，如果'tID是一个聚合索引'，
那么'后一句仅仅从表的10000条以后的记录中查找就行了'；而'前一句则要先从全表中查找看有几个name="zhangsan"的'，
而后再根据限制条件条件tID>10000来提出查询结果。 

事实上，'这样的担心是不必要的'。SQL SERVER中有一个“'查询分析优化器'”，它可以'计算出where子句中的搜索条件'并
'确定哪个索引能缩小表扫描的搜索空间'，也就是说，它能实现'自动优化'。虽然查询优化器可以根据'where子句自动的进行查询优化'，
但'有时查询优化器'就'会不按照您的本意'进行'快速查询'。 在查询分析阶段，
查询优化器查看查询的'每个阶段'并决定限制'需要扫描的数据量是否有用'。如果'一个阶段可以被用作一个扫描参数（SARG）'，
那么就称之为'可优化'的，并且可以'利用索引快速获得所需数据'。 
'SARG'的定义：用于'限制搜索的一个操作'，因为它通常是指'一个特定的匹配'，'一个值的范围内的匹配'或者'两个以上条件的AND连接'。形式如下： 
列名 操作符 <常数 或 变量> 或 <常数 或 变量> 操作符 列名 
'列名'可以出现'在操作符的一边'，而'常数或变量'出现'在操作符的另一边'。如： 
'Name=’张三’'
'价格>5000'
'5000<价格' 
'Name=’张三’ and 价格>5000' 
如果'一个表达式''不能满足SARG的形式'，那'它就无法限制搜索的范围'了，也就是SQL SERVER'必须对每一行'都'判断它是否满足WHERE子句中的所有条件'。
所以'一个索引'对于'不满足SARG形式的表达式来说是无用的'。
所以，优化查询最重要的就是，尽量'使语句符合查询优化器的规则''避免全表扫描而使用索引查询'。

具体要注意的：

1.应尽量'避免在 where 子句中'对字段'进行 null 值判断'，否则将导致引擎放弃使用索引而进行全表扫描，如：
select id from t where num is null
可以'在num上设置默认值0'，'确保表中num列没有null值'，然后这样查询：
select id from t where num=0

2.应尽量'避免在 where 子句中使用!=或<>操作符'，否则将'引擎放弃使用索引'而'进行全表扫描'。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。

3.应尽量'避免在 where 子句中使用 or 来连接条件'，否则将导致引擎放弃使用索引而进行全表扫描，如：
select id from t where num=10 or num=20
可以这样查询：
select id from t where num=10
union all
select id from t where num=20

4.in 和 not in 也要慎用，因为'IN会使系统无法使用索引,而只能直接搜索表中的数据'。如：
select id from t where num in(1,2,3)
对于连续的数值，能用 between 就不要用 in 了：
select id from t where num between 1 and 3

5.尽量'避免在索引过的字符数据中'，使'用非打头字母搜索'。这也使得引擎无法利用索引。 
见如下例子： 
SELECT * FROM T1 WHERE NAME LIKE ‘%L%’ 
SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=’L’ 
SELECT * FROM T1 WHERE NAME LIKE ‘L%’ 
即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。

6.必要时'强制查询优化器使用某个索引'，如在 'where 子句中使用参数'，也'会导致全表扫描'。因为SQL只有'在运行时才会解析局部变量'，
但'优化程序''不能将访问计划的选择''推迟到运行时'；它必须'在编译时进行选择'。然而，如果'在编译时''建立访问计划'，'变量的值还是未知的'，
因而'无法作为索引选择的输入项'。如下面语句将进行全表扫描：
select id from t where num=@num
可以改为'强制查询使用索引'：
select id from t with(index(索引名)) where num=@num

7.应尽量'避免在 where 子句中''对字段进行表达式操作'，这将'导致引擎放弃使用索引'而进行全表扫描。如：
SELECT * FROM T1 WHERE F1/2=100 
应改为: 
SELECT * FROM T1 WHERE F1=100*2

SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=’5378’ 
应改为: 
SELECT * FROM RECORD WHERE CARD_NO LIKE ‘5378%’

SELECT member_number, first_name, last_name FROM members 
WHERE DATEDIFF(yy,datofbirth,GETDATE()) > 21 
应改为: 
SELECT member_number, first_name, last_name FROM members 
WHERE dateofbirth < DATEADD(yy,-21,GETDATE()) 
即：'任何对列的操作'都将'导致表扫描'，它包括'数据库函数'、'计算表达式等等'，查询时要尽可能将操作移至等号右边。

8.应尽量'避免在where子句中''对字段进行函数操作'，这将导致引擎放弃使用索引而进行全表扫描。如：
select id from t where substring(name,1,3)='abc'--name以abc开头的id
select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id
应改为:
select id from t where name like 'abc%'
select id from t where createdate>='2005-11-30' and createdate<'2005-12-1'

9.'不要'在 where 子句中的'“=”左边进行函数'、'算术运算'或'其他表达式运算'，否则系统将可能无法正确使用索引。

10.在'使用索引字段作为条件时'，如果该'索引是复合索引'，那么必须'使用到该索引中'的'第一个字段'作'为条件时'
'才能保证'系统'使用该索引'，否则该索引将不会被使用，并且应'尽可能的让字段顺序'与'索引顺序相一致'。

11.很多时候用 exists是一个好的选择：
select num from a where num in(select num from b)
用下面的语句替换：
select num from a where exists(select 1 from b where num=a.num)

SELECT SUM(T1.C1)FROM T1 WHERE(
(SELECT COUNT(*)FROM T2 WHERE T2.C2=T1.C2>0) 
SELECT SUM(T1.C1) FROM T1WHERE EXISTS( 
SELECT * FROM T2 WHERE T2.C2=T1.C2) 
两者产生相同的结果，但是后者的效率显然要高于前者。因为'后者不会产生大量锁定的表扫描'或是'索引扫描'。

如果你想'校验表里是否存在某条纪录'，'不要用count(*)'那样'效率很低'，而且浪费服务器资源。可以'用EXISTS代替'。如： 
IF (SELECT COUNT(*) FROM table_name WHERE column_name = 'xxx') 
可以写成： 
IF EXISTS (SELECT * FROM table_name WHERE column_name = 'xxx')

经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父结果集中有而在子结果集中没有的记录，如： 
SELECT a.hdr_key FROM hdr_tbl a---- tbl a 表示tbl用别名a代替
WHERE NOT EXISTS (SELECT * FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key) 
SELECT a.hdr_key FROM hdr_tbl a
LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULL 
SELECT hdr_key FROM hdr_tbl 
WHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl) 
三种写法都可以得到同样正确的结果，但是效率依次降低。

12.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

13.'避免'频繁'创建和删除临时表'，以减少系统表资源的消耗。

14.临时表并不是不可使用，适当地'使用它们'可以使'某些例程更有效'，例如，当'需要重复引用大型表'或'常用表中的某个数据集时'。
但是，对于一次性事件，最好使用导出表。

15.在'新建临时表'时，如果一次性'插入数据量很大'，那么可以'使用 select into 代替 create table，避免造成大量 log '，
以提高速度；如果'数据量不大'，'为了缓和系统表的资源'，应先'create table，然后insert'。

16.'如果使用到了临时表'，'在存储过程的最后'务必'将所有的临时表显式删除'，先 'truncate table' ，'然后 drop table' ，
这样'可以避免系统表的较长时间锁定'。 

17.在'所有的存储过程和触发器'的开始处'设置 SET NOCOUNT ON' ，在'结束时设置 SET NOCOUNT OFF' 。
无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。

18.尽量'避免大事务操作'，'提高系统并发能力'。

19.尽量'避免向客户端返回大数据量'，若数据量过大，应该考虑相应需求是否合理。 

20. '避免使用不兼容的数据类型'。例如float和int、char和varchar、binary和varbinary是不兼容的。
数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如: 
SELECT name FROM employee WHERE salary > 60000
在这条语句中,如salary字段是float型的,则优化器很难对其进行优化,因为60000是个整型数。
我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。

21.充分'利用连接条件'，在某种情况下，'两个表'之间'可能不只一个的连接条件'，这时在 WHERE '子句中将连接条件完整的写上'，
有可能大大提高查询速度。 
例：
SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO 
SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO
第二句将比第一句执行快得多。

22、使用视图加速查询 
'把表'的一个'子集进行排序'并'创建视图'，有时'能加速查询'。它有助于'避免多重排序' 操作，而且在其他方面'还能简化优化器的工作'。例如：
SELECT cust.name，rcvbles.balance，……other columns 
FROM cust，rcvbles 
WHERE cust.customer_id = rcvlbes.customer_id 
AND rcvblls.balance>0 
AND cust.postcode>“98000” 
ORDER BY cust.name

如果这个查询'要被执行多次'而不止一次，'可以把所有未付款的客户'找出来'放在一个视图中'，并'按客户的名字'进行'排序'： 
CREATE VIEW DBO.V_CUST_RCVLBES 
AS
SELECT cust.name，rcvbles.balance，……other columns 
FROM cust，rcvbles 
WHERE cust.customer_id = rcvlbes.customer_id 
AND rcvblls.balance>0 
ORDER BY cust.name 
然后'以下面的方式''在视图中查询'： 
SELECT columns FROM V_CUST_RCVLBES 
WHERE postcode>“98000” 
'视图中的行'要'比主表中的行少'，而且'物理顺序就是所要求的顺序'，减少了磁盘I/O，所以查询'工作量可以得到大幅减少'。

23、能用DISTINCT的就不用GROUP BY
SELECT OrderID FROM Details WHERE UnitPrice > 10 GROUP BY OrderID 
可改为： 
SELECT DISTINCT OrderID FROM Details WHERE UnitPrice > 10

24.能用UNION ALL就不要用UNION 
UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源 
35.尽量不要用SELECT INTO语句。 
SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。

    上面我们提到的是一些基本的'提高查询速度的注意事项',但是在更多的情况下,往往'需要反复试验比较不同的语句'以'得到最佳方案'。
最好的方法当然是测试，看实现'相同功能的SQL语句''哪个执行时间最少'，但是数据库中'如果数据量很少'，是比较不出来的，
这时'可以用查看执行计划'，即：'把实现相同功能的多条SQL语句考到查询分析器'，按'CTRL+L看查所利用的索引'，
表扫描次数（这两个对性能影响最大），总体上看询成本百分比即可。 
三、算法的优化

	尽量'避免使用游标'，因为游标的'效率较差'，如果'游标操作的数据超过1万行'，那么就应该'考虑改写'。
.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。与临时表一样，
游标并不是不可使用。对小型数据集使用 FAST_FORWARD '游标通常要优于其他逐行处理方法'，
尤其是在'必须引用几个表'才能'获得所需的数据'时。在结果集中'包括“合计”的例程'通常要'比使用游标执行的速度快'。
如果'开发时间允许'，基于'游标的方法和基于集的方法'都可以'尝试一下'，看哪一种方法的效果更好。
　　游标提供了对特定集合中逐行扫描的手段，一般使用游标逐行遍历数据，根据取出的数据不同条件进行不同的操作。
尤其'对多表'和'大表定义的游标'（大的数据集合）循环很'容易使程序进入一个漫长的等特甚至死机'。
　   在有些场合，有时也非得使用游标，此时也可考虑将符合条件的数据行转入临时表中，再对临时表定义游标进行操作，可时性能得到明显提高。
（例如：对内统计第一版）
封装存储过程

四、建立高效的索引

　 创建索引一般有以下两个目的：'维护被索引列的唯一性'和'提供快速访问表中数据的策略'。大型数据库有'两种索引'即'簇索引'和'非簇索引'，
一个'没有簇索引的表'是按'堆结构存储数据'，所有的'数据'均添加'在表的尾部'，而建立了'簇索引的表'，其'数据'在物理上会'按照簇索引键'的'顺序存储'，
一个'表只允许有一个簇索引'，因此，根据'B树结构'，可以理'解添加任何一种索引'均'能提高按索引列查询的速度'，但会降低插入、更新、删除操作的性能，
尤其是当'填充因子（Fill Factor）较大'时。
所以'对索引较多的表'进行频繁的'插入、更新、删除'操作，'建表和索引时'因'设置较小的填充因子'，
以便'在各数据页'中'留下较多的自由空间'，'减少页分割'及'重新组织的工作'。 '索引'是'从数据库中''获取数据'的'最高效方式之一'。
'95%' 的'数据库性能问题'都可以'采用索引技术得到解决'。
	作为'一条规则'，我'通常对逻辑主键''使用唯一的成组索引'，
对'系统键'（'作为存储过程'）'采用唯一的非成组索引'，对'任何外键列'[字段]'采用非成组索引'。不过，索引就象是盐，太多了菜就咸了。
你得'考虑数据库的空间有多大'，'表如何进行访问'，还有'这些访问是否主要用作读写'。 
	实际上，您可以'把索引'理解'为一种特殊的目录'。微软的SQL SERVER提供了'两种索引'：'聚集索引'（clustered index，也称聚类索引、簇集索引）
和'非聚集索引'（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下'聚集索引'和'非聚集索引'的区别： 
其实，我们的汉语字典的正文本身就是一个'聚集索引'。比如，我们'要查“安”字'，就会很自然地'翻开字典的前几页'，因为“安”的'拼音是“an”'，
而'按照拼音排序'汉字的'字典是以英文字母“a”开头'并'以“z”结尾'的，那么'“安”'字就自然地'排在字典的前部'。如果您'翻完了'所有'以“a”开头的部分'
仍然找不到这个字，那么就'说明您的字典'中'没有这个字'；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，
'字典的正文部分'本身就'是一个目录'，您'不需要再去查其他目录'来'找到您需要找的内容'。 
我们把这种'正文内容''本身就是'一种'按照一定规则排列'的目录'称为“聚集索引”'。
如果您'认识某个字'，您可以快速地从'自动中查到这个字'。但您'也可能'会'遇到'您'不认识的字'，不知道它的发音，这时候，您就'不能'按'照刚才的方法''找到'您要查的字，
而需要去'根据'“'偏旁部首'”查到您要找的字，然后'根据这个字后的页码'直接翻到某页来找到您要找的字。
但您'结合“部首目录”'和'“检字表”'而查到的字的'排序并不是'真正的'正文的排序方法'，比'如'您'查“张”字'，我们可以看到在'查部首之后'的检字表中'“张”的页码是672页'，
检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。'很显然'，这些'字并不是真正的分别''位于“张”字的上下方'，
现在您看到的连续的'“驰、张、弩”'三字实际上就是他们在'非聚集索引'中的'排序'，是字典正文中的字在非聚集索引中的映射。
我们'可以通过这种方式'来'找到您所需要的字'，但'它需要两个过程'，'先找到目录中的结果'，然后'再翻到您所需要的页码'。 
我们把这种'目录纯粹是目录'，'正文纯粹是正文'的排序方式称为“'非聚集索引'”。
进一步'引申'一下，我们可以很容易的理解：'每个表'只能'有一个聚集索引'，因为目录只能按照一种方法进行排序。

（一）何时使用'聚集索引'或'非聚集索引' 
下面的表总结了'何时使用聚集索引'或'非聚集索引'（很重要）。 
	动作描述 	使用聚集索引 	使用非聚集索引 
'列'经常'被分组排序' 应 				应
返回'某范围内的数据' 	应 				不应
一个或极少不同值 	不应 			不应
'小数目'的'不同值' 	应	 			不应
'大数目'的'不同值' 	不应				应
'频繁更新'的列 		不应 			应
'外键列' 			应 				应
'主键列' 			应 				应
频繁'修改索引'列 	不应 			应


事实上，我们可以通过前面'聚集索引'和'非聚集索引'的定义的例子'来理解上表'。如：返回某范围内的数据一项。
比如您的'某个表有'一个'时间列'，恰好您把'聚合索引''建立在了该列'，这时您'查询2004年1月1日至2004年10月1日之间的'全部'数据'时，
这个'速度就将是很快的'，因为您的'这本字典'正文是'按日期进行排序的'，'聚类索引'只需要'找到要检索'的所有'数据中的开头'和'结尾数据'即可；
而不像'非聚集索引'，必须先'查到目录中查到每一项数据对应的页码'，然后再'根据页码查到具体内容'。


（二）结合实际，谈'索引使用的误区'

理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。
下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。 
1、'主键就是聚集索引'
'这种想法'笔者认为'是极端错误的'，是对'聚集索引的一种浪费'。虽然SQL SERVER默认是在主键上建立聚集索引的。 
'通常'，'我们会在'每个'表中都建立一个ID列'，以区分每条数据，并且这个'ID列是自动增大的'，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。
此时，'如果'我们'将这个列设为主键'，'SQL SERVER'会将此列'默认为聚集索引'。这样做有'好处'，就'是可以让您的数据在数据库中'按'照ID进行物理排序'，
但笔者认为这样做意义不大。 
显而易见，'聚集索引'的'优势'是很'明显'的，而'每个表中只能'有'一个聚集索引的规则'，这使得'聚集索引变得更加珍贵'。 
从我们前面谈到的'聚集索引'的定义我们可以看出，使用聚集索引的'最大好处'就是'能够根据查询要求'，迅速'缩小查询范围'，避免全表扫描。
在实际应用中，因为'ID号是自动生成的'，我们'并不知道每条记录的ID号'，所以我们'很难在实践中用ID号来进行查询'。这就使让'ID号'这个主键'作为聚集索引'成'为一种资源浪费'。
其次，让'每个ID号'都'不同的字段'作为'聚集索引也不符合'“'大数目的不同值'情况下'不应建立聚合索引'”规则；
当然，这种情况只是'针对用户'经常'修改记录内容'，'特别是索引项'的时候会负作用，但'对于查询速度并没有影响'。 
在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、
会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。 
通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。'虽然'我们的'where语句'可以仅仅'限制当前用户尚未签收的情况'，
但如果您的'系统已建立了很长时间'，并且'数据量很大'，那么，每次'每个用户打开首页'的时候'都进行一次全表扫描'，这样做'意义是不大的'，
绝大'多数的用户''1个月前的文件都已经浏览过了'，这样做只能'徒增数据库的开销'而已。事实上，我们完全'可以让用户打开系统首页时'，
数据库仅仅'查询这个用户近3个月来未阅览的文件'，通过'“日期”这个字段来限制表扫描'，提高查询速度。
如果'您的办公自动化系统'已经'建立的2年'，那么'您的首页显示速度'理论上将'是原来速度8倍，甚至更快'。

2、'只要建立索引''就能显著提高查询速度'
事实上，我们可以发现上面的例子中，'第2、3条语句完全相同'，且建立'索引的字段也相同'；不同的仅是'前者在fariqi字段上建立'的是'非聚合索引'，
'后者在此字段上建立'的是'聚合索引'，但查询'速度却有着天壤之别'。所以，'并非是在任何字段上简单地建立索引'就'能提高查询速度'。
从建表的语句中，我们可以看到这个有着'1000万数据'的表中'fariqi字段'有'5003个不同记录'。在'此字段上建立聚合索引'是再合适不过了。
在'现实中'，我们'每天都会发几个文件'，这几个文件的'发文日期'就相同，
这完全'符合建立聚集索引要求'的：“'既不能'绝'大多数都相同'，'又不能'只有'极少数相同'”的规则。
由此看来，我们'建立“适当”的聚合索引'对于我们'提高查询速度'是非常重要的。

3、'把所有需要''提高查询速度的字段'都'加进聚集索引'，以提高查询速度 
上面已经谈到：在进行'数据查询时'都'离不开字段的是“日期”'还有'用户本身的“用户名”'。
既然这'两个字段都是如此的重要'，我们可以'把他们合并起来'，'建立一个复合索引'（compound index）。 
'很多人认为只要把任何字段加进聚集索引'，就'能提高查询速度'，也有人感到迷惑：
如果把'复合的聚集索引字段''分开查询'，那么'查询速度会减慢'吗？带着这个问题，
我们来'看一下'以下的'查询速度'
（结果集都是25万条数据）：（'日期列fariqi'首'先排在'复合'聚集索引的起始列'，'用户名neibuyonghu排在后列'） 
我们可以看到如果'仅用聚集索引'的'起始列作为查询条件'和'同时用到复合聚集索引的全部列'的'查询速度是几乎一样的'，
'甚至比用上全部的复合索引'列'还要略快'（在查询结果集数目一样的情况下）；
而'如果仅用复合聚集索引'的'非起始列作为查询条件'的话，这个'索引是不起任何作用的'。
当然，'语句1、2的查询速度一样'是'因为查询的条目数一样'，如果'复合索引'的所有列都用上，
而且'查询结果少'的话，这样就'会形成“索引覆盖”'，因而'性能可以达到最优'。同时，请记住：
'无论'您'是否经常使用聚合索引'的'其他列'，但'其前导列'一定'要是使用最频繁'的列。

（三）其他注意事项 
“水可载舟，亦可覆舟”，索引也一样。'索引有助'于'提高'检索'性能'，但'过多'或'不当的索引'也会'导致系统低效'。
因为'用户在表'中'每加进一个索引'，'数据库'就要'做更多的工作'。'过多的索引'甚至会'导致索引碎片'。 
所以说，我们要'建立一个“适当”的索引体系'，特别是'对聚合索引'的创建，更应精益求精，以使您的数据库能得到高性能的发挥


