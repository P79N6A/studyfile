死锁的定义： 当'多个进程'同时'访问一个数据库'时，其中的'每个进程'拥有的'资源'都'是其他进程所需'的，由此造成的'每个进程都无法继续下去'的情况。  
死锁产生的原因：
一般情况只发生锁超时，就是'一个进程'需要'访问'数据库'表'或者字段的时候，'另外一个程序'正在'执行带锁的访问'（比如修改数据），那么'这个进程就会等待'，
当等了'很久锁还没有解除'的话就会锁超时，报告一个系统错误，'拒绝执行相应的SQL操作'。
      死锁产生的四个必要条件：
1）'互斥条件'：指进程对所分配到的资源进行排它性使用，即在一段时间内'某资源'只'由一个进程占用'。如果此时还有'其它进程请求资源'，
则请求者只能等待，直'至占有资源'的'进程用毕释放'。
2）'请求和保持条件'：指'进程'已经'保持至少一个资源'，但又'提出'了'新的资源'请求，而该'资源'已'被其它进程占有'，此时请求'进程阻塞'，
但'又对自己已获得的其它资源保持不放'。
3）'不剥夺条件'：指'进程已获得的资源'，在'未使用完之前'，不能被剥夺，'只能在使用完'时由'自己释放'。
4）'环路等待条件'：指在发生死锁时，必然存在'一个进程''——个资源'的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
减少和防止死锁产生的方法：
在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。
最大限度降低死锁的产生的方法：
a. 按同一顺序访问对象：
        按同一顺序访问对象也就是：'第一个事务提交或回滚后'，'第二个事务继续进行'，这样不会发生死锁。
b. 避免事务中的用户交互：
         '避免编写包含用户交互的事务'，因为运行'没有用户交互的批处理的速度'要远远'快于用户手动响应查询的速度'，
         例如'答复应用程序'请求'参数的提示'。例如，如果'事务正在等待用户输入'，而用户去吃午餐了或者甚至回家过周末了，
         则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。
         即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。
c. 保持'事务简短''并在一个批处理中'：
         在'同一数据库'中'并发执行多个'需要'长时间运行的事务'时通常'发生死锁'。事务'运行时间越长'，其持有'排它锁或更新锁'的'时间也就越长'，
         从而'堵塞了其它活动'并可能'导致死锁'。 保持事务在一个批处理中，可以最小化事务的网络通信往返量，'减少完成事务可能的延迟并释放锁'。
d. 使用低隔离级别：
     确定事务是否能在更低的隔离级别上运行，执行提交读取允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读取）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。
e. 使用绑定连接：
     使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞。
对产生的死锁的建议：
(1)对于频繁使用的表使用'集簇化的索引';
(2)设法'避免一次性影响大量记录的T-SQL语句'，特别是'INSERT和UPDATE语句';
(3)设法让UPDATE和DELETE语句使用索引;
(4)使用嵌套事务时，避免提交和回退冲突;
(5)对一些数据'不需要''及时''读取更新值''的表'在写SQL的时候在表后台加上(nolock)，如：Select * from tableA(nolock)
-


问题描述： 一个'优惠券''活动'，用户可以'领取''优惠券'，但是'一个优惠券'活动'领取''数量有限'制，
所以用户'在领取'的时候就'需要先统计'一下以'领用的优惠券数量'。 然后在'生成'这张优惠券'领取记录'。
那么此时就'会出现''并发问题'，当'多个用户''领取同一个优惠券'活动的时候，他们'统计的优惠券已领数量'
'小于'限定'可领取数量'，所以'都可以执行生成' 优惠券'领取记录的操作'，但是'剩下的可领取数量'
可能'小于这些用户数量'。

'如何'来'解决这个问题'呢，首先我们会想到，在程序中'使用synchronized'关键字来'锁住领取优惠券'的方法，
那么'就可以实现'，当'一个人'在'领取优惠券'的时候'其他人等待'，但是'程序' 都是'分发到多台服务器'的，
在'分布式'的'情况下'，这种方法并'没有效果'，因为'程序中'所'能做到的'只是'锁住单台服务器'上面'的操作'。

既然'程序'中'无法实现'，那么我们就想到'利用数据库'来'实现'，因为我现在做的这个项目，'数据库'是
'没'用'从库'的，'只有一台数据库''服务器'，'如果''数据库也分布式'了，那'就要另求它法'了。

想到'用数据库解决'后，首先想到的是'利用事务'的'原子性'来'解决'，就是'统计已领用数量'的'操作'和
'生成优惠券记录'的操作'合成为一个事务'，表面上感觉可以了，但其实'这样做也是错误'的。 因为'多个事务'
'同时处理'时，情况也是一样的，同样会出现并发问题。

所以单单利用事务还是不行的，还必须使用'数据库'的'锁机制'。

'InnoDB'实现了以下'两种类型的行锁'。

共享锁（S）：'允许一个事务'去'读一行'，'阻止其他事务''获得相同数据集'的'排他锁'('可以读不能写')。

排他锁（X)：'允许获得排他锁的事务''更新数据'，'阻止其他事务''取得相同数据集'的'共享读锁'和
'排他写锁'('不能读也不能写')。

锁的范围:'行锁': 对'某行记录加上锁' ; '表'锁: 对'整个表加上锁'

此处我们需要使用的是'排它锁'，就是'当一个事物'在'进行操作的时候'，'其他事物''不能去统计''已经领取'
'优惠券的数量'，'只有领取完成之后'才能'统计'。'锁的范围是行'。

使用'排他锁'的方法其实'是悲观锁机制'，我们还有乐观锁，接下来就先介绍下二者区别。

悲观锁：'假定''会发生并发冲突'，'屏蔽''一切可能违反数据完整性''的操作'。

'悲观锁'假定'其他用户'企图访问或者'改变你正在访问'、更改'的对象'的概率是很高的，因此在悲观锁的环境中，
在'你开始改变此对象'之'前'就'将该对象锁住'，并且直到'你提交了'所作的'更改之后'才'释放锁'。 
悲观的'缺陷'是'不论是页锁'还是'行锁'，加锁的'时间'可能'会很长'，这样可能'会长时间'的'限制其他用户'
的'访问'，也就是说悲观锁的并发'访问性不好'。

乐观锁：假设'不会''发生并发'冲突，只在'提交操作'时'检查''是否违反''数据完整性'。

'乐观锁''不能解决''脏读'的问题。 '乐观锁'则'认为其他用户'企图'改变你正在更改的对象'的'概率是很小的'，
因此'乐观锁'直到'你准备提交所作的更改时''才将对象锁住'，当'你读取'以及'改变该对象时''并不加锁'。 
可见'乐观锁加锁的时间'要'比悲观锁短'，乐观锁可以用较大的锁粒度获得'较好的并发访问性能'。
但是'如果第二个用户''恰好'在'第一个用户''提交更改'之'前读取了该对象'，那么当'他完成'了自己的'更改进行提交时'， 
'数据库就会发现该对象已经变化了'，这样，'第二个用户不得不重新读取该对象并作出更改'。
这说明在乐观锁环境中，会'增加并发用户读取对象的次数'。

如果使用乐观锁的方式，我们就需要'给数据库'有'当前优惠券活动已领取数量'的'字段'，
'每次'我们'修改这个字段的值时''对其就行判断'，如果'他小于可领取数量'，那么'久可以插入' 这条优惠券记录。
这样判断和更新是在同一条sql中，这样就'利用一条sql的原子性'，'避免并发冲突'。


项目推到线上后就报错了
错误中提示下面这条sql发生了死锁
UPDATE coupon SET coup_num_usr = coup_num_usr + 1 WHERE coup_usr = ? 
AND spec_id = ? AND coup_num_usr < ?

首先我们来看下coupon的表结构	
CREATE TABLE `coupon` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT ' ',
  `spec_id` char(20) NOT NULL COMMENT '优惠券活动编号',
  `coup_usr` char(11) DEFAULT NULL COMMENT '优惠券用户',
  `coup_num_usr` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '该用户已领取该活动的券数量',
  PRIMARY KEY (`id`),
  KEY `coup_usr_idx` (`coup_usr`),
  KEY `spec_idx` (`spec_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8508 DEFAULT CHARSET=utf8 COMMENT='优惠券';


其中'coup usr'和'spec id'是索引，
mysql的'事务支持''与存储引擎''有关'，'MyISAM不支持事务'，'INNODB支持事务'，'更新时'采用的是'行级锁'。
这里采用的是'INNODB做存储引擎'，意味着会'将update语句''做'为'一个事务'来处理。前面提到'行级锁'必须
'建立在索引的基础'，'这条更新语句''用到了索引'，所以'这里肯定会加上行级锁'。 '行级锁'并'不是直接锁'
记录，而是'锁索引'，如果'一条SQL语句''用到'了'主键索引'，'mysql'会'锁住''主键索引'；如果'一条语句'
'操作'了'非主键索引'，'mysql'会'先锁住非主键索引'，'再锁定主键索引'。 这个'update'语句会'执行''以下'
'步骤'：1、由于用到了非主键索引，'首先'需要'获取普通索引'上的'行级锁 '；
	    2、'紧接着'根据主键进行更新，所以需要'获取主键'上的'行级锁'；
	    3、更新完毕后，'提交，并释放所有锁'。
如果在'步骤1和2'之间突然'插入一条语句'：
UPDATE coupon SET coup num usr = coup num usr + 1 WHERE coup usr = ? AND spec id = ? AND coup num usr < ?
就'会发生死锁'的情况，因为'一条语句获取了普通索引的锁'，'等待主键锁'，'另'外'一条语句''获取了主键锁'，
等待'非主键索引'，这样就出现了死锁.
如何来解决'update ... where ...'语句的'死锁问题'呢？我们可以对其进行分离，'首先''利用where条件'
'找到主键'，然后'再利用'这些'主键去更新数据'。
因为'select * where ...'语句是'没有锁'的，所以'不存在会锁上where条件里面的字段'，也就'不会发生死锁的情况'，
只有'在update的时候'回'锁上主键'。
所以改成下面两条语句
SELECT id WHERE coup_usr = ? AND spec_id = ?
UPDATE coupon SET coup_num_usr = coup_num_usr + 1 WHERE id = ? AND coup_num_usr < ?

第'一'条语句'找出'所有'需要更新行'的'主键id'，然后'再''一条一条更新'。

在采用INNODB的MySQL中，'更新操作'默认会'加行级锁'，'行级锁'是'基于索引'的，在'分析死锁之前'需要'查询'一下
mysql的'执行计划'，看看'是否用到了索引'，用到了哪个索引，'对于没有用索引的操作'会'采用表级锁'。
如果操作'用到了主键索引'会'先在主键索引上加锁'，'然后'在'其他索引上加锁'，'否则加锁顺序相反'。
在'并发度高'的应用中，'批量更新'一定要'带上记录的主键'，优先'获取主键上的锁'，这样可以'减少死锁'的发生。



首先  lock in share mode 这个是共享锁，被他锁定的 其他进程能够查看，不能修改
	  for update 这个是排他锁，被他锁定的 其他进程不能查看，不能修改
 
死锁案列  用索引和键的处理，获取的是行锁，用其他字段处理，需要获取的是表锁
'进程1  拿到行锁还没提交事务'
update table set name = 'X' where id = '1'; 
'进程2  等待进程1的行锁'
update table set name = 'X' where id = '1';
'进程1接着操作,这个是需要表锁的  等待进程2释放资源'   如果进程1接着请求的是行锁而不是表锁，不会出现这个问题！！！【可能是mysql做了优化】
update table set name = 'X' where name = 'Y';
'如下  1需要2的锁    2又需要1的锁，导致死锁'
1--->2;  2--->1